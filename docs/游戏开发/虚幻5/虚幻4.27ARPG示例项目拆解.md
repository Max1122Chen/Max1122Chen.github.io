# 虚幻4.27ARPG示例项目拆解

## PART I Inventory & Item

### 1. 整体概览：

​	ARPG示例中，把武器、药水、货币、技能都抽象成了“物品”（Item），以下是该项目认为的他们所共有的属性：

- **所属Item类别（FPrimaryAssetType ItemType）**

- **自己的名字（FText ItemName）**

- 对物品的描述（FText ItemDescription）（可在蓝图中编辑并查看）

- 在编辑器中的图标（FSlateBrush ItemIcon）

- 购买价格（int32 Price）

- **最大数量（int32 MaxCount）**

- 最大等级（int32 MaxLevel）

- 获取该物品可授予玩家的GameplayAbility（TSubclassOf<URPGGameplayAbility> GrantedAbility）

- 授予技能的最大等级（int32 AbilityLevel）

  

  ​	只需关注加粗条目，它们在各个项目中具有共通性。你可能好奇，为什么没有物品的数量？物品的持有者，物品的来历，获得物品的时间等等，这是因为这些属性并非一类物品的自有属性，就比如你在讨论常规语境下“书”是什么时，讨论的不是具体某一本书，而是对于所有物理意义上的书一般会有的属性，例如书一般是纸做的，是什么类型的纸另说，书一般是用来看的，书一般会有文字和图像，而书的数量是讨论一堆书的时候涉及的，书的持有者、来历等等是具体到某一本或几本书时才有意义的。

  ​	而我们要构建一个物品管理系统Inventory，那肯定要涉及到“管什么”（已回答，就是上面的Item）“怎么管”和“管多少”。

  ​	作为一位管理员，我已经明确我要管辖的范围了，就是上面的Item的全体，那我总需要记录每类物品有多少吧，甚至具体某件物品的具体信息吧，每类物品放在哪吧。ARPG示例项目的Inventory这位管理员给出了它的方案：

  ​	它说：

  ​	我定义两种基本数据结构：

  1. ItemData，用来记录某种Item的具体信息，在这里我只需要记录Item的数量ItemCount，ItemData本身与具体的Item无关，需要有人来给他们建立关系，待会我们来做这件事

  2. ItemSlot，我把存Item的地方叫做Slot（插槽），这只是一种好记的名字，叫box，chest其实都无所谓，ItemSlot中存了两个信息：

     - ItemType，当前存储Item的类别，比如是药水、武器、护甲？

     - SlotNumber，这个Slot的编号。

       ItemSlot本身也与具体的Item无关，你可能会疑惑，为什么不需要定义Slot的最大存储量呢？

       ​	试想这样的情形：你在Minecraft中，普通方块的最大堆叠数是64，告示牌、末影珍珠等的最大堆叠数是16，武器、护甲、附魔书的最大堆叠数是1，而它们存储的空间都是物品栏的一个格子，是格子决定了它们的最大堆叠数吗？很显然当然不是，它们堆叠多少，必然是一个游戏规则赋予它们的”属性“了，这就是说最大堆叠数是游戏物品的一个常有属性，我们有没有呢?有!在上面已经列出来了。但是这样我们怎么控制Item的最大堆叠数呢？

     

     ​	实际上，在该项目的inventory管理思想中，Slot仅仅只是一个地址，Item的数量由ItemData管理，我们只需要在改变ItemData时，控制ItemData的ItemCount不能超过它关联的Item的MaxCount就可以了。

     ​	但是Item，ItemData，ItemSlot怎么关联呢？

     ​	这就需要管理员Inventory的参与了。

     ​	Inventory做了两张表：每张表涉及两种不同的元素，不妨一个叫Key，一个叫Value，每张表的单个元素有一个唯一对应的另一种元素，Key到Value构成了一种一一映射。且我们规定已知Key可以找到对应的Value，反过来不允许。

     1. 第一张表，叫做InventoryData，Key是Item，Value是ItemData

     2. 第二张表，叫做SlottedItem，Key是ItemSlot，Value是Item

        ​	这样，我们对于一个Slot（如果这个Slot已经在表上了），我们能通过查表知道它存的物品（可能不存在），再进一步InventoryData知道它在Inventory中有几个了。

### 2. Item起源：UItem，ItemType：ItemSlot，ItemData

​	ARPG示例中，选择从UPrimaryDataAsset中派生出来UItem，这里的Item是抽象的，并不需要实体，所以选择派生自一个非Actor类，并且Item继承FPrimaryAsset使其能够与一个FPrimaryAssetId结构体关联，实际上是因为重写了父类PrimaryAsset中的GetPrimaryAssetId()方法，重写代码如下：

```c++
FPrimaryAssetId URPGItem::GetPrimaryAssetId() const
{
    // This is a DataAsset and not a blueprint so we can just use the raw FName
    // For blueprints you need to handle stripping the _C suffix
    return FPrimaryAssetId(ItemType, GetFName());//这是FPrimaryAssetId(ItemType, GetFName())的有参构造
}
```

​	可以看到struct FPrimaryAssetId主要就是含有两个成员PrimaryAssetType，PrimaryAssetName，所以FPrimaryAssetId其实是把Item中的FPrimaryAssetType ItemType和FText ItemName打包了一下。

```c++
struct FPrimaryAssetId
{
    /** An FName describing the logical type of this object, usually the name of a base UClass. For example, any Blueprint derived from APawn will have a Primary Asset Type of "Pawn".
    "PrimaryAssetType:PrimaryAssetName" should form a unique name across your project. */
    FPrimaryAssetType PrimaryAssetType;
    /** An FName describing this asset. This is usually the short name of the object, but could be a full asset path for things like maps, or objects with GetPrimaryId() overridden.
    "PrimaryAssetType:PrimaryAssetName" should form a unique name across your project. */
    FName PrimaryAssetName;

    /** Static names to represent the AssetRegistry tags for the above data */
    static COREUOBJECT_API const FName PrimaryAssetTypeTag;
    static COREUOBJECT_API const FName PrimaryAssetNameTag;

    FPrimaryAssetId() {}

    FPrimaryAssetId(FPrimaryAssetType InAssetType, FName InAssetName)
       : PrimaryAssetType(InAssetType), PrimaryAssetName(InAssetName)
    {}
    
	[……]
}
```

**UItem**

```c++
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "ActionRPG.h"//重要
//在该示例中，"ActionRPG.h"用于引入一些频繁要用到的头文件，类似一个“头文件夹”
//其中包含了头文件"RPGTypes.h"，放在后面
#include "Engine/DataAsset.h"
#include "Styling/SlateBrush.h"
#include "RPGAssetManager.h"
#include "RPGItem.generated.h"

class URPGGameplayAbility;

/** Base class for all items, do not blueprint directly */
UCLASS(Abstract, BlueprintType)
class ACTIONRPG_API URPGItem : public UPrimaryDataAsset
{
	GENERATED_BODY()

public:
	/** Constructor */
	URPGItem()
		: Price(0)
		, MaxCount(1)
		, MaxLevel(1)
		, AbilityLevel(1)
	{}

	/** Type of this item, set in native parent class */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Item)
	FPrimaryAssetType ItemType;

	/** User-visible short name */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Item)
	FText ItemName;

	/** User-visible long description */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Item)
	FText ItemDescription;

	/** Icon to display */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Item)
	FSlateBrush ItemIcon;

	/** Price in game */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Item)
	int32 Price;

	/** Maximum number of instances that can be in inventory at once, <= 0 means infinite */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Max)
	int32 MaxCount;

	/** Returns if the item is consumable (MaxCount <= 0)*/
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = Max)
	bool IsConsumable() const;

	/** Maximum level this item can be, <= 0 means infinite */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Max)
	int32 MaxLevel;

	/** Ability to grant if this item is slotted */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Abilities)
	TSubclassOf<URPGGameplayAbility> GrantedAbility;

	/** Ability level this item grants. <= 0 means the character level */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Abilities)
	int32 AbilityLevel;

	/** Returns the logical name, equivalent to the primary asset id */
	UFUNCTION(BlueprintCallable, Category = Item)
	FString GetIdentifierString() const;

	/** Overridden to use saved type */
	virtual FPrimaryAssetId GetPrimaryAssetId() const override;
};
```

​	URPGItem类声明了Item所共有的基本属性，包括

- 所属Item类别（FPrimaryAssetType ItemType），

- 自己的名字（FText ItemName）

- 对物品的描述（FText ItemDescription）（可在蓝图中编辑并查看）

- 在编辑器中的图标（FSlateBrush ItemIcon）

- 购买价格（int32 Price）

- 最大数量（int32 MaxCount）

- 最大等级（int32 MaxLevel）

- 获取该物品可授予玩家的GameplayAbility（TSubclassOf<URPGGameplayAbility> GrantedAbility）

- 授予技能的最大等级（int32 AbilityLevel）

  

  ​	这些就构成了一个Item所需的基本属性，而Item的数量，与Inventory的互通等，都在"RPGType.h"中通过结构ItemData和ItemSlot负责，可以说RPGType.h才是实现了Item的融合骨肉，同时，"RPGType.h"声明了许多动态多播委托，这些委托与Inventory的更新，加载，以及SaveGame的加载有关。说明Inventory的实现是交给PlayerController来做的，事实正是如此，在后面继续拆解。
  
  ​	ItemType中ItemData与ItemSlot分别管理Item在Inventory中的实际数量与在Inventory中占据的“槽位”（Slot）。ItemData与它表现的Item无关，它只是一个用来表达Item在Inventory中的值的“工具人”，并没有得到特定Item的青睐。
  
  ​	而ItemSlot只存储一个FPrimaryAssetType ItemType和一个int32 SlotNumber（可见下）
  
  
  
  RPGType.h

```c++
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

// ----------------------------------------------------------------------------------------------------------------
// This header is for enums and structs used by classes and blueprints accross the game
// Collecting these in a single header helps avoid problems with recursive header includes
// It's also a good place to put things like data table row structs
// ----------------------------------------------------------------------------------------------------------------

#include "UObject/PrimaryAssetId.h"
#include "RPGTypes.generated.h"

class URPGItem;
class URPGSaveGame;

/** Struct representing a slot for an item, shown in the UI */
USTRUCT(BlueprintType)
struct ACTIONRPG_API FRPGItemSlot
{
	GENERATED_BODY()

	/** Constructor, -1 means an invalid slot */
	FRPGItemSlot()
		: SlotNumber(-1)
	{}

	FRPGItemSlot(const FPrimaryAssetType& InItemType, int32 InSlotNumber)
		: ItemType(InItemType)
		, SlotNumber(InSlotNumber)
	{}

	/** The type of items that can go in this slot */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Item)
	FPrimaryAssetType ItemType;

	/** The number of this slot, 0 indexed */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Item)
	int32 SlotNumber;

	/** Equality operators */
	bool operator==(const FRPGItemSlot& Other) const
	{
		return ItemType == Other.ItemType && SlotNumber == Other.SlotNumber;
	}
	bool operator!=(const FRPGItemSlot& Other) const
	{
		return !(*this == Other);
	}

	/** Implemented so it can be used in Maps/Sets */
	friend inline uint32 GetTypeHash(const FRPGItemSlot& Key)
	{
		uint32 Hash = 0;

		Hash = HashCombine(Hash, GetTypeHash(Key.ItemType));
		Hash = HashCombine(Hash, (uint32)Key.SlotNumber);
		return Hash;
	}

	/** Returns true if slot is valid */
	bool IsValid() const
	{
		return ItemType.IsValid() && SlotNumber >= 0;
	}
};


/** Extra information about a URPGItem that is in a player's inventory */
USTRUCT(BlueprintType)
struct ACTIONRPG_API FRPGItemData
{
	GENERATED_BODY()

	/** Constructor, default to count/level 1 so declaring them in blueprints gives you the expected behavior */
	FRPGItemData()
		: ItemCount(1)
		, ItemLevel(1)
	{}

	FRPGItemData(int32 InItemCount, int32 InItemLevel)
		: ItemCount(InItemCount)
		, ItemLevel(InItemLevel)
	{}

	/** The number of instances of this item in the inventory, can never be below 1 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Item)
	int32 ItemCount;

	/** The level of this item. This level is shared for all instances, can never be below 1 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Item)
	int32 ItemLevel;

	/** Equality operators */
	bool operator==(const FRPGItemData& Other) const
	{
		return ItemCount == Other.ItemCount && ItemLevel == Other.ItemLevel;
	}
	bool operator!=(const FRPGItemData& Other) const
	{
		return !(*this == Other);
	}

	/** Returns true if count is greater than 0 */
	bool IsValid() const
	{
		return ItemCount > 0;
	}

	/** Append an item data, this adds the count and overrides everything else */
	void UpdateItemData(const FRPGItemData& Other, int32 MaxCount, int32 MaxLevel)
	{
		if (MaxCount <= 0)
		{
			MaxCount = MAX_int32;
		}

		if (MaxLevel <= 0)
		{
			MaxLevel = MAX_int32;
		}

		ItemCount = FMath::Clamp(ItemCount + Other.ItemCount, 1, MaxCount);
		ItemLevel = FMath::Clamp(Other.ItemLevel, 1, MaxLevel);
	}
};

//这些委托在PlayerControllerBase.h中绑定，Inventory的逻辑由PlayerCOntrolled实现

/** Delegate called when an inventory item changes */
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnInventoryItemChanged, bool, bAdded, URPGItem*, Item);
DECLARE_MULTICAST_DELEGATE_TwoParams(FOnInventoryItemChangedNative, bool, URPGItem*);

/** Delegate called when the contents of an inventory slot change */
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnSlottedItemChanged, FRPGItemSlot, ItemSlot, URPGItem*, Item);
DECLARE_MULTICAST_DELEGATE_TwoParams(FOnSlottedItemChangedNative, FRPGItemSlot, URPGItem*);

/** Delegate called when the entire inventory has been loaded, all items may have been replaced */
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnInventoryLoaded);
DECLARE_MULTICAST_DELEGATE(FOnInventoryLoadedNative);

/** Delegate called when the save game has been loaded/reset */
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnSaveGameLoaded, URPGSaveGame*, SaveGame);
DECLARE_MULTICAST_DELEGATE_OneParam(FOnSaveGameLoadedNative, URPGSaveGame*);
```

### 3. PlayerControllerBase重点拆解

​	再看PlayerControllerBase.h，PlayerControllerBase中有两个TMap成员属性，这两个成员属性由于只是VisibleAnyWhere只显示在类默认值中且不可编辑，他们负责管理Inventory中真实的物品类别的逻辑上的数据和物品在Inventory的Slot中的存储表现，可以说，即使没有Slot，Item在Inventory中仍有其逻辑上的数据，只不过无法与其在Inventory中的逻辑“位置”相关。

```c++
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Inventory)
TMap<URPGItem*, FRPGItemData> InventoryData;
//可以通过Inventory.Find(Item)来获取Item对应的ItemData，这样特定的Item才与一个ItemData产生关联

/** Map of slot, from type/num to item, initialized from ItemSlotsPerType on RPGGameInstanceBase */
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Inventory)
TMap<FRPGItemSlot, URPGItem*> SlottedItems;
//可以通过SlottedItems.Find.(ItemSlot)找到对应槽位的Item.
```

#### 3.1 AddInventoryItem()

这个方法管理的是某个Item在Inventory中的逻辑上的数量，与它在Slot中的表现无关。

```c++
bool ARPGPlayerControllerBase::AddInventoryItem(URPGItem* NewItem, int32 ItemCount, int32 ItemLevel, bool bAutoSlot)
{
    bool bChanged = false;
    if (!NewItem)
    {
       UE_LOG(LogActionRPG, Warning, TEXT("AddInventoryItem: Failed trying to add null item!"));
       return false;
    }

    if (ItemCount <= 0 || ItemLevel <= 0)
    {
       UE_LOG(LogActionRPG, Warning, TEXT("AddInventoryItem: Failed trying to add item %s with negative count or level!"), *NewItem->GetName());
       return false;
    }

    // Find current item data, which may be empty
    FRPGItemData OldData;//创建一个中介变量OldData
    GetInventoryItemData(NewItem, OldData);
    //GetInventoryItemData()的实现：这里的临时变量命名不太好，FoundItem明明存储的是形参Item映射到的ItemData，叫FoundItemData更好，该方法并非“获取”InventoryItemData，而是先检查输入的Item是否存在，存在的判定依据为是否能找到其映射出的ItemData，如可以，返回true表示存在，如找不到，把传入的ItemData设置为（0，0），便于新建一个关于该Item的ItemData
    /*bool ARPGPlayerControllerBase::GetInventoryItemData(URPGItem* Item, FRPGItemData& ItemData) const
{
	const FRPGItemData* FoundItem = InventoryData.Find(Item);

	if (FoundItem)
	{
		ItemData = *FoundItem;
		return true;
	}
	ItemData = FRPGItemData(0, 0);
	return false;
}
*/

    // Find modified data
    FRPGItemData NewData = OldData;//依据GetInventoryItem处理得到的OldData设置NewData
    NewData.UpdateItemData(FRPGItemData(ItemCount, ItemLevel), NewItem->MaxCount, NewItem->MaxLevel);
	//UpdateItemData的实现,在此根据传入的参数增加NewData的值
    /*
    void UpdateItemData(const FRPGItemData& Other, int32 MaxCount, int32 MaxLevel)
	{
		if (MaxCount <= 0)
		{
			MaxCount = MAX_int32;
		}

		if (MaxLevel <= 0)
		{
			MaxLevel = MAX_int32;
		}

		ItemCount = FMath::Clamp(ItemCount + Other.ItemCount, 1, MaxCount);
		ItemLevel = FMath::Clamp(Other.ItemLevel, 1, MaxLevel);
	}
    */
    //应该是防止无端的使用造成无效更新和回调吧，虽然默认参数增加的数目是1
    if (OldData != NewData)
    {
       // If data changed, need to update storage and call callback
       InventoryData.Add(NewItem, NewData);
       NotifyInventoryItemChanged(true, NewItem);
       bChanged = true;
    }
	
    //需不需要自动为新加入到Inventory的Item增加Inventory槽位
    if (bAutoSlot)
    {
       // Slot item if required
       bChanged |= FillEmptySlotWithItem(NewItem);
    }

    if (bChanged)
    {
       // If anything changed, write to save game
       SaveInventory();
       return true;
    }
    return false;
}
```

#### 3.2 FillEmptySlotWithItem()

​	这个方法实现的是把新的物品填进Inventory中的空的Slot，不过ARPG示例中并没有规定Inventory中的最大Slot数，所以只要有新的未加入Inventory的item来者不拒。这个方法就很好地体现了为什么ItemSlot结构中只存储了一个FPrimaryAssetType ItemType，也就是只关心Item的大类，而不是一个具体的Item个体。下面的方法通过遍历TMap SlottedItems，先依据FPrimaryAssetType ItemType做初步筛选，一个条件判断就排除了其他类，接下来在NewItem的ItemType的该层级下寻找是否已经有NewItem这个物品占据的Slot了，如果有，无需填入新Slot，fill失败，如果没有在NewItem的ItemType中找到该种物品，且有ItemType这个分类的空Slot，

```c++
bool ARPGPlayerControllerBase::FillEmptySlotWithItem(URPGItem* NewItem)
{
    // Look for an empty item slot to fill with this item
    FPrimaryAssetType NewItemType = NewItem->GetPrimaryAssetId().PrimaryAssetType;
    FRPGItemSlot EmptySlot;//新增一个空Slot，作为预备
    for (TPair<FRPGItemSlot, URPGItem*>& Pair : SlottedItems)
    {
       if (Pair.Key.ItemType == NewItemType)
       {
          if (Pair.Value == NewItem)
          {
             // Item is already slotted
             return false;
          }
          else if (Pair.Value == nullptr && (!EmptySlot.IsValid() || EmptySlot.SlotNumber > Pair.Key.SlotNumber))
              /*ItemSlot的valid判定是<=0为valid，而ItemSlot的默认构造只初始化SlotNumber为-1，这里的&&后的条件相当于要				保证默认构造产生的是一个无效的Slot，避免破坏其他的可能存有item的Slot*/
          {
             // We found an empty slot worth filling
             EmptySlot = Pair.Key;
             //把找到的NewItem.ItemType类别的Slot赋值给EmptySlot，表示它是空的
          }
       }
    }
    
    if (EmptySlot.IsValid())
	{
		SlottedItems[EmptySlot] = NewItem;
		NotifySlottedItemChanged(EmptySlot, NewItem);
		return true;
        //在SlottedItems中把NewItem绑定给EmptySlot，并广播，返回插入成功
	}

	return false;
}
```

#### 3.3 GetSlottedItems

​	这个方法在蓝图的BP_PlayerCharacter中被调用，神奇的是这个方法被蓝图调用的时候是不需要传递TArray Items的，也就是说这个方法是根据传入的ItemType来筛选所需要的Item类别，最后”返回“一个TArray

```c++
void ARPGPlayerControllerBase::GetSlottedItems(TArray<URPGItem*>& Items, FPrimaryAssetType ItemType, bool bOutputEmptyIndexes)
{
    for (TPair<FRPGItemSlot, URPGItem*>& Pair : SlottedItems)
    {
       if (Pair.Key.ItemType == ItemType || !ItemType.IsValid())
       {
          Items.Add(Pair.Value);
       }
    }
}
```

## PART II Save Game & Game Instance

​	ARPG示例项目的Save Game主要涉及的就是Save玩家的Inventory中的Items，这部分涉及到了USaveGame，UGameInstance，AssetManager。PrimaryDataAsset等内容。

​	首先我们来着眼于SaveGame，通过它我们能够了解到ARPG示例项目保存的内容。

### 1. RPGSaveGame

RPGSaveGame.h

```c++
#include "ActionRPG.h"
#include "Items/RPGItem.h"
#include "GameFramework/SaveGame.h"
#include "RPGSaveGame.generated.h"

/** List of versions, native code will handle fixups for any old versions */
namespace ERPGSaveGameVersion
{
    enum type
    {
       // Initial version
       Initial,
       // Added Inventory
       AddedInventory,
       // Added ItemData to store count/level
       AddedItemData,

       // -----<new versions must be added before this line>-------------------------------------------------
       VersionPlusOne,
       LatestVersion = VersionPlusOne - 1
    };
}

/** Object that is written to and read from the save game archive, with a data version */
UCLASS(BlueprintType)
class ACTIONRPG_API URPGSaveGame : public USaveGame
{
    GENERATED_BODY()

public:
    /** Constructor */
    URPGSaveGame()
    {
       // Set to current version, this will get overwritten during serialization when loading
       SavedDataVersion = ERPGSaveGameVersion::LatestVersion;
    }

    /** Map of items to item data */
    UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = SaveGame)
    TMap<FPrimaryAssetId, FRPGItemData> InventoryData;

    /** Map of slotted items */
    UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = SaveGame)
    TMap<FRPGItemSlot, FPrimaryAssetId> SlottedItems;

    /** User's unique id */
    UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = SaveGame)
    FString UserId;

protected:
    /** Deprecated way of storing items, this is read in but not saved out */
    UPROPERTY()
    TArray<FPrimaryAssetId> InventoryItems_DEPRECATED;

    /** What LatestVersion was when the archive was saved */
    UPROPERTY()
    int32 SavedDataVersion;

    /** Overridden to allow version fixups */
    virtual void Serialize(FArchive& Ar) override;
};
```

​	可以看到，SaveGame主要通过两个TMap来保存玩家的Inventory物品信息。我们可以注意到，SaveGame中使用了FPrimaryAssetId而非PrimaryAsset，这点我们会在之后去分析。

​	所以，SaveGame其实主要就是通过Map保存了ItemAsset即PrimaryDataAsset和Item的实际数量即ItemData或和ItemSlot的关系。ARPG项目中，Item的Data和Item的存储的Slot是分开管理的。

​	事实上，GameInstance主要只负责SaveGame的加载和保存，也就是把某个槽位上的SaveGame拿出来或者放进去，真正的去把新的游戏状态写入或读取的逻辑是在PlayerController中完成的，其实PlayerController在Inventory系统的角度它就是充当了Inventory的管理员。

### 2. RPGGameInstance

​	简单看一下GameInstance：

URPGGameInstanceBase.h

```c++
#include "ActionRPG.h"
#include "Engine/GameInstance.h"
#include "RPGGameInstanceBase.generated.h"

class URPGItem;
class URPGSaveGame;

/**
 * Base class for GameInstance, should be blueprinted
 * Most games will need to make a game-specific subclass of GameInstance
 * Once you make a blueprint subclass of your native subclass you will want to set it to be the default in project settings
 */
UCLASS()
class ACTIONRPG_API URPGGameInstanceBase : public UGameInstance
{
    GENERATED_BODY()

public:
    // Constructor
    URPGGameInstanceBase();

    /** List of inventory items to add to new players */
    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Inventory)
    TMap<FPrimaryAssetId, FRPGItemData> DefaultInventory;

    /** Number of slots for each type of item */
    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Inventory)
    TMap<FPrimaryAssetType, int32> ItemSlotsPerType;

    /** The slot name used for saving */
    UPROPERTY(BlueprintReadWrite, Category = Save)
    FString SaveSlot;

    /** The platform-specific user index */
    UPROPERTY(BlueprintReadWrite, Category = Save)
    int32 SaveUserIndex;

    /** Delegate called when the save game has been loaded/reset */
    UPROPERTY(BlueprintAssignable, Category = Inventory)
    FOnSaveGameLoaded OnSaveGameLoaded;

    /** Native delegate for save game load/reset */
    FOnSaveGameLoadedNative OnSaveGameLoadedNative;

    /**
     * Adds the default inventory to the inventory array
     * @param InventoryArray Inventory to modify
     * @param RemoveExtra If true, remove anything other than default inventory
     */
    UFUNCTION(BlueprintCallable, Category = Inventory)
    void AddDefaultInventory(URPGSaveGame* SaveGame, bool bRemoveExtra = false);

    /** Returns true if this is a valid inventory slot */
    UFUNCTION(BlueprintCallable, Category = Inventory)
    bool IsValidItemSlot(FRPGItemSlot ItemSlot) const;

    /** Returns the current save game, so it can be used to initialize state. Changes are not written until WriteSaveGame is called */
    UFUNCTION(BlueprintCallable, Category = Save)
    URPGSaveGame* GetCurrentSaveGame();

    /** Sets rather save/load is enabled. If disabled it will always count as a new character */
    UFUNCTION(BlueprintCallable, Category = Save)
    void SetSavingEnabled(bool bEnabled);

    /** Synchronously loads a save game. If it fails, it will create a new one for you. Returns true if it loaded, false if it created one */
    UFUNCTION(BlueprintCallable, Category = Save)
    bool LoadOrCreateSaveGame();

    /** Handle the final setup required after loading a USaveGame object using AsyncLoadGameFromSlot. Returns true if it loaded, false if it created one */
    UFUNCTION(BlueprintCallable, Category = Save)
    bool HandleSaveGameLoaded(USaveGame* SaveGameObject);

    /** Gets the save game slot and user index used for inventory saving, ready to pass to GameplayStatics save functions */
    UFUNCTION(BlueprintCallable, Category = Save)
    void GetSaveSlotInfo(FString& SlotName, int32& UserIndex) const;

    /** Writes the current save game object to disk. The save to disk happens in a background thread*/
    UFUNCTION(BlueprintCallable, Category = Save)
    bool WriteSaveGame();

    /** Resets the current save game to it's default. This will erase player data! This won't save to disk until the next WriteSaveGame */
    UFUNCTION(BlueprintCallable, Category = Save)
    void ResetSaveGame();

protected:
    /** The current save game object */
    UPROPERTY()
    URPGSaveGame* CurrentSaveGame;

    /** Rather it will attempt to actually save to disk */
    UPROPERTY()
    bool bSavingEnabled;

    /** True if we are in the middle of doing a save */
    UPROPERTY()
    bool bCurrentlySaving;

    /** True if another save was requested during a save */
    UPROPERTY()
    bool bPendingSaveRequested;

    /** Called when the async save happens */
    virtual void HandleAsyncSave(const FString& SlotName, const int32 UserIndex, bool bSuccess);
};
```

URPGGameInstanceBase.cpp

```c++
#include "RPGGameInstanceBase.h"
#include "RPGAssetManager.h"
#include "RPGSaveGame.h"
#include "Items/RPGItem.h"
#include "Kismet/GameplayStatics.h"

URPGGameInstanceBase::URPGGameInstanceBase()
    : SaveSlot(TEXT("SaveGame"))
    , SaveUserIndex(0)
{}

void URPGGameInstanceBase::AddDefaultInventory(URPGSaveGame* SaveGame, bool bRemoveExtra)
{
    // If we want to remove extra, clear out the existing inventory
    if (bRemoveExtra)
    {
       SaveGame->InventoryData.Reset();
    }

    // Now add the default inventory, this only adds if not already in hte inventory
    for (const TPair<FPrimaryAssetId, FRPGItemData>& Pair : DefaultInventory)
    {
       if (!SaveGame->InventoryData.Contains(Pair.Key))
       {
          SaveGame->InventoryData.Add(Pair.Key, Pair.Value);
       }
    }
}

bool URPGGameInstanceBase::IsValidItemSlot(FRPGItemSlot ItemSlot) const
{
    if (ItemSlot.IsValid())
    {
       const int32* FoundCount = ItemSlotsPerType.Find(ItemSlot.ItemType);

       if (FoundCount)
       {
          return ItemSlot.SlotNumber < *FoundCount;
       }
    }
    return false;
}

URPGSaveGame* URPGGameInstanceBase::GetCurrentSaveGame()
{
    return CurrentSaveGame;
}

void URPGGameInstanceBase::SetSavingEnabled(bool bEnabled)
{
    bSavingEnabled = bEnabled;
}

bool URPGGameInstanceBase::LoadOrCreateSaveGame()
{
    URPGSaveGame* LoadedSave = nullptr;

    if (UGameplayStatics::DoesSaveGameExist(SaveSlot, SaveUserIndex) && bSavingEnabled)
    {
       LoadedSave = Cast<URPGSaveGame>(UGameplayStatics::LoadGameFromSlot(SaveSlot, SaveUserIndex));
    }

    return HandleSaveGameLoaded(LoadedSave);
}

bool URPGGameInstanceBase::HandleSaveGameLoaded(USaveGame* SaveGameObject)
{
    bool bLoaded = false;

    if (!bSavingEnabled)
    {
       // If saving is disabled, ignore passed in object
       SaveGameObject = nullptr;
    }

    // Replace current save, old object will GC out
    CurrentSaveGame = Cast<URPGSaveGame>(SaveGameObject);

    if (CurrentSaveGame)
    {
       // Make sure it has any newly added default inventory
       AddDefaultInventory(CurrentSaveGame, false);
       bLoaded = true;
    }
    else
    {
       // This creates it on demand
       CurrentSaveGame = Cast<URPGSaveGame>(UGameplayStatics::CreateSaveGameObject(URPGSaveGame::StaticClass()));

       AddDefaultInventory(CurrentSaveGame, true);
    }

    OnSaveGameLoaded.Broadcast(CurrentSaveGame);
    OnSaveGameLoadedNative.Broadcast(CurrentSaveGame);

    return bLoaded;
}

void URPGGameInstanceBase::GetSaveSlotInfo(FString& SlotName, int32& UserIndex) const
{
    SlotName = SaveSlot;
    UserIndex = SaveUserIndex;
}

bool URPGGameInstanceBase::WriteSaveGame()
{
    if (bSavingEnabled)
    {
       if (bCurrentlySaving)
       {
          // Schedule another save to happen after current one finishes. We only queue one save
          bPendingSaveRequested = true;
          return true;
       }

       // Indicate that we're currently doing an async save
       bCurrentlySaving = true;

       // This goes off in the background
       UGameplayStatics::AsyncSaveGameToSlot(GetCurrentSaveGame(), SaveSlot, SaveUserIndex, FAsyncSaveGameToSlotDelegate::CreateUObject(this, &URPGGameInstanceBase::HandleAsyncSave));
       return true;
    }
    return false;
}

void URPGGameInstanceBase::ResetSaveGame()
{
    // Call handle function with no loaded save, this will reset the data
    HandleSaveGameLoaded(nullptr);
}

void URPGGameInstanceBase::HandleAsyncSave(const FString& SlotName, const int32 UserIndex, bool bSuccess)
{
    ensure(bCurrentlySaving);
    bCurrentlySaving = false;

    if (bPendingSaveRequested)
    {
       // Start another save as we got a request while saving
       bPendingSaveRequested = false;
       WriteSaveGame();
    }
}
```

### 3. PlayerController中关于SaveGame的逻辑

#### 3.1 SaveInventory

```c++
bool ARPGPlayerControllerBase::SaveInventory()
{
    UWorld* World = GetWorld();
    URPGGameInstanceBase* GameInstance = World ? World->GetGameInstance<URPGGameInstanceBase>() : nullptr;

    if (!GameInstance)
    {
       return false;
    }

    URPGSaveGame* CurrentSaveGame = GameInstance->GetCurrentSaveGame();
    if (CurrentSaveGame)
    {
       // Reset cached data in save game before writing to it
       CurrentSaveGame->InventoryData.Reset();
       CurrentSaveGame->SlottedItems.Reset();

       for (const TPair<URPGItem*, FRPGItemData>& ItemPair : InventoryData)
       {
          FPrimaryAssetId AssetId;

          if (ItemPair.Key)
          {
             AssetId = ItemPair.Key->GetPrimaryAssetId();
             CurrentSaveGame->InventoryData.Add(AssetId, ItemPair.Value);
          }
       }

       for (const TPair<FRPGItemSlot, URPGItem*>& SlotPair : SlottedItems)
       {
          FPrimaryAssetId AssetId;

          if (SlotPair.Value)
          {
             AssetId = SlotPair.Value->GetPrimaryAssetId();
          }
          CurrentSaveGame->SlottedItems.Add(SlotPair.Key, AssetId);
       }

       // Now that cache is updated, write to disk
       GameInstance->WriteSaveGame();
       return true;
    }
    return false;
}
```

​	可以看到，PlayerController中的每一次的SaveInventory实际上就是把当前玩家持有的Inventory以覆写的方式存入GameInstance当前持有的SaveGame（CurrentSaveGame）。

​	要注意SaveGame中没有具体的PrimaryAsset，只有FPrimaryAssetId，所以从PlayerController向SaveGame保存信息时需要从PrimaryAsset拿到它的FPrimaryAssetId。

#### 3.2 LoadInventory

```c++
bool ARPGPlayerControllerBase::LoadInventory()
{
    InventoryData.Reset();
    SlottedItems.Reset();

    // Fill in slots from game instance
    UWorld* World = GetWorld();
    URPGGameInstanceBase* GameInstance = World ? World->GetGameInstance<URPGGameInstanceBase>() : nullptr;

    if (!GameInstance)
    {
       return false;
    }

    // Bind to loaded callback if not already bound
    if (!GameInstance->OnSaveGameLoadedNative.IsBoundToObject(this))
    {
       GameInstance->OnSaveGameLoadedNative.AddUObject(this, &ARPGPlayerControllerBase::HandleSaveGameLoaded);
    }

    for (const TPair<FPrimaryAssetType, int32>& Pair : GameInstance->ItemSlotsPerType)
    {
       for (int32 SlotNumber = 0; SlotNumber < Pair.Value; SlotNumber++)
       {
          SlottedItems.Add(FRPGItemSlot(Pair.Key, SlotNumber), nullptr);
       }
    }

    URPGSaveGame* CurrentSaveGame = GameInstance->GetCurrentSaveGame();
    URPGAssetManager& AssetManager = URPGAssetManager::Get();
    if (CurrentSaveGame)
    {
       // Copy from save game into controller data
       bool bFoundAnySlots = false;
       for (const TPair<FPrimaryAssetId, FRPGItemData>& ItemPair : CurrentSaveGame->InventoryData)
       {
          URPGItem* LoadedItem = AssetManager.ForceLoadItem(ItemPair.Key);

          if (LoadedItem != nullptr)
          {
             InventoryData.Add(LoadedItem, ItemPair.Value);
          }
       }

       for (const TPair<FRPGItemSlot, FPrimaryAssetId>& SlotPair : CurrentSaveGame->SlottedItems)
       {
          if (SlotPair.Value.IsValid())
          {
             URPGItem* LoadedItem = AssetManager.ForceLoadItem(SlotPair.Value);
             if (GameInstance->IsValidItemSlot(SlotPair.Key) && LoadedItem)
             {
                SlottedItems.Add(SlotPair.Key, LoadedItem);
                bFoundAnySlots = true;
             }
          }
       }

       if (!bFoundAnySlots)
       {
          // Auto slot items as no slots were saved
          FillEmptySlots();
       }

       NotifyInventoryLoaded();

       return true;
    }

    // Load failed but we reset inventory, so need to notify UI
    NotifyInventoryLoaded();

    return false;
}
```

​	可以注意到，从SaveGame中LoadInventory要稍微复杂一点，需要通过PrimaryAssetId，用AssetManager把对应的PrimaryAsset加载出来，本质上是要根据PrimaryAssetId得到PrimaryAsset的资源路径，然后通过资源路径得到这个Asset，这需要调用AssetManager的方法GetPrimaryAssetPath().

URPGAssetManager::ForceLoadItem的定义

```c++
URPGItem* URPGAssetManager::ForceLoadItem(const FPrimaryAssetId& PrimaryAssetId, bool bLogWarning)
{   
    FSoftObjectPath ItemPath = GetPrimaryAssetPath(PrimaryAssetId);

    // This does a synchronous load and may hitch
    URPGItem* LoadedItem = Cast<URPGItem>(ItemPath.TryLoad());

    if (bLogWarning && LoadedItem == nullptr)
    {
       UE_LOG(LogActionRPG, Warning, TEXT("Failed to load item for identifier %s!"), *PrimaryAssetId.ToString());
    }

    return LoadedItem;
}
```

##### 3.1.1 Item的PrimaryAssetId 的实现

​	Item的PrimaryAssetId要实现需要为其定义PrimaryAssetType，因为FPrimaryAssetId()要用它来生成Id，所以需要为其定义一个AssetType。

​	ARPG示例项目中，选择了通过AssetManager统一定义Item的一系列AssetType静态成员变量，以便可以在项目中通过调用AssetManager静态对象方便地获取到它。

.h

![image-20250215154357652](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250215154357652.png)

.cpp

![image-20250215154447133](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250215154447133.png)

> [!IMPORTANT]
>
> ​	注意注意，使用PrimaryAsset需要在config中配置对应的扫描资产的信息，需要手动修改DefaultGame中的内容，如ARPG中：
>
> [/Script/Engine.AssetManagerSettings]
> -PrimaryAssetTypesToScan=(PrimaryAssetType="Map",AssetBaseClass=/Script/Engine.World,bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path="/Game/Maps")))
> -PrimaryAssetTypesToScan=(PrimaryAssetType="PrimaryAssetLabel",AssetBaseClass=/Script/Engine.PrimaryAssetLabel,bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path="/Game")))
> +PrimaryAssetTypesToScan=(PrimaryAssetType="Map",AssetBaseClass=/Script/Engine.World,bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path="/Game/Maps")),SpecificAssets=,Rules=(Priority=-1,bApplyRecursively=True,ChunkId=-1,CookRule=Unknown))
> +PrimaryAssetTypesToScan=(PrimaryAssetType="PrimaryAssetLabel",AssetBaseClass=/Script/Engine.PrimaryAssetLabel,bHasBlueprintClasses=False,bIsEditorOnly=False,Directories=((Path="/Game")),SpecificAssets=,Rules=(Priority=-1,bApplyRecursively=True,ChunkId=-1,CookRule=Unknown))
> +PrimaryAssetTypesToScan=(PrimaryAssetType="Potion",AssetBaseClass=/Script/ActionRPG.RPGPotionItem,bHasBlueprintClasses=False,bIsEditorOnly=False,Directories=((Path="/Game/Items/Potions")),SpecificAssets=,Rules=(Priority=-1,bApplyRecursively=True,ChunkId=-1,CookRule=AlwaysCook))
> +PrimaryAssetTypesToScan=(PrimaryAssetType="Skill",AssetBaseClass=/Script/ActionRPG.RPGSkillItem,bHasBlueprintClasses=False,bIsEditorOnly=False,Directories=((Path="/Game/Items/Skills")),SpecificAssets=,Rules=(Priority=-1,bApplyRecursively=True,ChunkId=-1,CookRule=AlwaysCook))
> +PrimaryAssetTypesToScan=(PrimaryAssetType="Token",AssetBaseClass=/Script/ActionRPG.RPGTokenItem,bHasBlueprintClasses=False,bIsEditorOnly=False,Directories=((Path="/Game/Items/Tokens")),SpecificAssets=,Rules=(Priority=-1,bApplyRecursively=True,ChunkId=-1,CookRule=AlwaysCook))
> +PrimaryAssetTypesToScan=(PrimaryAssetType="Weapon",AssetBaseClass=/Script/ActionRPG.RPGWeaponItem,bHasBlueprintClasses=False,bIsEditorOnly=False,Directories=((Path="/Game/Items/Weapons")),SpecificAssets=,Rules=(Priority=-1,bApplyRecursively=True,ChunkId=-1,CookRule=AlwaysCook))
> bOnlyCookProductionAssets=False
> bShouldGuessTypeAndNameInEditor=True
> bShouldAcquireMissingChunksOnLoad=False

