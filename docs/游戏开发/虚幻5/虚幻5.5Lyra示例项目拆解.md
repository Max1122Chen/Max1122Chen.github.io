# 虚幻5.5Lyra示例项目拆解

## PART I 物品、物品栏、装备系统

## 1. LyraInventory

### 1.1 InventoryManagerComponent

​	Lyra项目中定义了一个InventoryManagerComponent来专门管理和Inventory相关的事宜。

​	InventoryManagerComponent由LyraPlayerController拥有，但是我死是找不到在LyraPlayerController的哪定义的InventoryManagerComponent？？？	

> [!NOTE]
>
> ​	解决了，原来是在GameFeature激活时才进行挂载在LyraPlayerController上。

InventoryManagerComponent.h

```c++
#include "Components/ActorComponent.h"
#include "Net/Serialization/FastArraySerializer.h"

#include "LyraInventoryManagerComponent.generated.h"

class ULyraInventoryItemDefinition;
class ULyraInventoryItemInstance;
class ULyraInventoryManagerComponent;
class UObject;
struct FFrame;
struct FLyraInventoryList;
struct FNetDeltaSerializeInfo;
struct FReplicationFlags;

/** A message when an item is added to the inventory */
USTRUCT(BlueprintType)
struct FLyraInventoryChangeMessage
{
	GENERATED_BODY()

	//@TODO: Tag based names+owning actors for inventories instead of directly exposing the component?
	UPROPERTY(BlueprintReadOnly, Category=Inventory)
	TObjectPtr<UActorComponent> InventoryOwner = nullptr;

	UPROPERTY(BlueprintReadOnly, Category = Inventory)
	TObjectPtr<ULyraInventoryItemInstance> Instance = nullptr;

	UPROPERTY(BlueprintReadOnly, Category=Inventory)
	int32 NewCount = 0;

	UPROPERTY(BlueprintReadOnly, Category=Inventory)
	int32 Delta = 0;
};

/** A single entry in an inventory */
USTRUCT(BlueprintType)
struct FLyraInventoryEntry : public FFastArraySerializerItem
{
	GENERATED_BODY()

	FLyraInventoryEntry()
	{}

	FString GetDebugString() const;

private:
	friend FLyraInventoryList;
	friend ULyraInventoryManagerComponent;

	UPROPERTY()
	TObjectPtr<ULyraInventoryItemInstance> Instance = nullptr;

	UPROPERTY()
	int32 StackCount = 0;

	UPROPERTY(NotReplicated)
	int32 LastObservedCount = INDEX_NONE;
};

/** List of inventory items */
USTRUCT(BlueprintType)
struct FLyraInventoryList : public FFastArraySerializer
{
	GENERATED_BODY()

	FLyraInventoryList()
		: OwnerComponent(nullptr)
	{
	}

	FLyraInventoryList(UActorComponent* InOwnerComponent)
		: OwnerComponent(InOwnerComponent)
	{
	}

	TArray<ULyraInventoryItemInstance*> GetAllItems() const;

public:
	//~FFastArraySerializer contract
	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
	//~End of FFastArraySerializer contract

	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
	{
		return FFastArraySerializer::FastArrayDeltaSerialize<FLyraInventoryEntry, FLyraInventoryList>(Entries, DeltaParms, *this);
	}

	ULyraInventoryItemInstance* AddEntry(TSubclassOf<ULyraInventoryItemDefinition> ItemClass, int32 StackCount);
	void AddEntry(ULyraInventoryItemInstance* Instance);

	void RemoveEntry(ULyraInventoryItemInstance* Instance);

private:
	void BroadcastChangeMessage(FLyraInventoryEntry& Entry, int32 OldCount, int32 NewCount);

private:
	friend ULyraInventoryManagerComponent;

private:
	// Replicated list of items
	UPROPERTY()
	TArray<FLyraInventoryEntry> Entries;

	UPROPERTY(NotReplicated)
	TObjectPtr<UActorComponent> OwnerComponent;
};

template<>
struct TStructOpsTypeTraits<FLyraInventoryList> : public TStructOpsTypeTraitsBase2<FLyraInventoryList>
{
	enum { WithNetDeltaSerializer = true };
};










/**
 * Manages an inventory
 */
UCLASS(BlueprintType)
class LYRAGAME_API ULyraInventoryManagerComponent : public UActorComponent
{
	GENERATED_BODY()

public:
	ULyraInventoryManagerComponent(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category=Inventory)
	bool CanAddItemDefinition(TSubclassOf<ULyraInventoryItemDefinition> ItemDef, int32 StackCount = 1);

	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category=Inventory)
	ULyraInventoryItemInstance* AddItemDefinition(TSubclassOf<ULyraInventoryItemDefinition> ItemDef, int32 StackCount = 1);

	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category=Inventory)
	void AddItemInstance(ULyraInventoryItemInstance* ItemInstance);

	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category=Inventory)
	void RemoveItemInstance(ULyraInventoryItemInstance* ItemInstance);

	UFUNCTION(BlueprintCallable, Category=Inventory, BlueprintPure=false)
	TArray<ULyraInventoryItemInstance*> GetAllItems() const;

	UFUNCTION(BlueprintCallable, Category=Inventory, BlueprintPure)
	ULyraInventoryItemInstance* FindFirstItemStackByDefinition(TSubclassOf<ULyraInventoryItemDefinition> ItemDef) const;

	int32 GetTotalItemCountByDefinition(TSubclassOf<ULyraInventoryItemDefinition> ItemDef) const;
	bool ConsumeItemsByDefinition(TSubclassOf<ULyraInventoryItemDefinition> ItemDef, int32 NumToConsume);

	//~UObject interface
	virtual bool ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
	virtual void ReadyForReplication() override;
	//~End of UObject interface

private:
	UPROPERTY(Replicated)
	FLyraInventoryList InventoryList;
};
```

​	Lyra的Inventory主要有这两个概念：**Entry**和**InventoryList**。

#### 1.1.1 Entry

​	Entry，在此语境中可翻译成“条目”“账目”比较适合。

​	Entry就类似于物品栏中的一个**格子**。

.h

```c++
/** A single entry in an inventory */
USTRUCT(BlueprintType)
struct FLyraInventoryEntry : public FFastArraySerializerItem
{
	GENERATED_BODY()

	FLyraInventoryEntry()
	{}

	FString GetDebugString() const;

private:
	friend FLyraInventoryList;
	friend ULyraInventoryManagerComponent;

	UPROPERTY()
	TObjectPtr<ULyraInventoryItemInstance> Instance = nullptr;

	UPROPERTY()
	int32 StackCount = 0;

	UPROPERTY(NotReplicated)
	int32 LastObservedCount = INDEX_NONE;
};
```

​	可以看到，一个Inventory中的“Entry”主要维护的成员是一个**ItemInstance**和一个**StackCount**。



#### 1.1.2 InventoryList

.h

```c++
/** List of inventory items */
USTRUCT(BlueprintType)
struct FLyraInventoryList : public FFastArraySerializer
{
	GENERATED_BODY()

	FLyraInventoryList()
		: OwnerComponent(nullptr)
	{
	}

	FLyraInventoryList(UActorComponent* InOwnerComponent)
		: OwnerComponent(InOwnerComponent)
	{
	}

	TArray<ULyraInventoryItemInstance*> GetAllItems() const;

public:
	//~FFastArraySerializer contract
	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
	//~End of FFastArraySerializer contract

	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
	{
		return FFastArraySerializer::FastArrayDeltaSerialize<FLyraInventoryEntry, FLyraInventoryList>(Entries, DeltaParms, *this);
	}

	ULyraInventoryItemInstance* AddEntry(TSubclassOf<ULyraInventoryItemDefinition> ItemClass, int32 StackCount);
	void AddEntry(ULyraInventoryItemInstance* Instance);

	void RemoveEntry(ULyraInventoryItemInstance* Instance);

private:
	void BroadcastChangeMessage(FLyraInventoryEntry& Entry, int32 OldCount, int32 NewCount);

private:
	friend ULyraInventoryManagerComponent;

private:
	// Replicated list of items
	UPROPERTY()
	TArray<FLyraInventoryEntry> Entries;

	UPROPERTY(NotReplicated)
	TObjectPtr<UActorComponent> OwnerComponent;
};
```

​	InventoryList主要就是维护了一个FLyraInventoryEntry的**数组**，并且还定义了一下List中**Entry**的增删的函数:AddEntry和RemoveEntry，这两个函数可以初始化新的Entry，并将其加入到List中去，还有一条Entry变动的委托。

##### Entry维护的ItemInstance的数量改变

​	对于Entry内维护的ItemInstance的数量的改变，由以下三个函数完成：

![image-20250128212450369](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250128212450369.png)

​	它们的实现：

```c++
// FLyraInventoryList

void FLyraInventoryList::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
{
    for (int32 Index : RemovedIndices)
    {
       FLyraInventoryEntry& Stack = Entries[Index];
       BroadcastChangeMessage(Stack, /*OldCount=*/ Stack.StackCount, /*NewCount=*/ 0);
       Stack.LastObservedCount = 0;
    }
}

void FLyraInventoryList::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)
{
    for (int32 Index : AddedIndices)
    {
       FLyraInventoryEntry& Stack = Entries[Index];
       BroadcastChangeMessage(Stack, /*OldCount=*/ 0, /*NewCount=*/ Stack.StackCount);
       Stack.LastObservedCount = Stack.StackCount;
    }
}

void FLyraInventoryList::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)
{
    for (int32 Index : ChangedIndices)
    {
       FLyraInventoryEntry& Stack = Entries[Index];
       check(Stack.LastObservedCount != INDEX_NONE);
       BroadcastChangeMessage(Stack, /*OldCount=*/ Stack.LastObservedCount, /*NewCount=*/ Stack.StackCount);
       Stack.LastObservedCount = Stack.StackCount;
    }
}
```

##### **AddEntry的实现**

```c++
ULyraInventoryItemInstance* FLyraInventoryList::AddEntry(TSubclassOf<ULyraInventoryItemDefinition> ItemDef, int32 StackCount)
{
	ULyraInventoryItemInstance* Result = nullptr;

	check(ItemDef != nullptr);
 	check(OwnerComponent);

	AActor* OwningActor = OwnerComponent->GetOwner();
	check(OwningActor->HasAuthority());


	FLyraInventoryEntry& NewEntry = Entries.AddDefaulted_GetRef();
	NewEntry.Instance = NewObject<ULyraInventoryItemInstance>(OwnerComponent->GetOwner());  //@TODO: Using the actor instead of component as the outer due to UE-127172
	NewEntry.Instance->SetItemDef(ItemDef);
	for (ULyraInventoryItemFragment* Fragment : GetDefault<ULyraInventoryItemDefinition>(ItemDef)->Fragments)
	{
		if (Fragment != nullptr)
		{
			Fragment->OnInstanceCreated(NewEntry.Instance);
		}
	}
	NewEntry.StackCount = StackCount;
	Result = NewEntry.Instance;

	//const ULyraInventoryItemDefinition* ItemCDO = GetDefault<ULyraInventoryItemDefinition>(ItemDef);
	MarkItemDirty(NewEntry);

	return Result;
}
```

​	值得注意这里对Entries（TArray）添加元素所调用的方法，是创建了一个新的Default的实例并且拿到它的引用，这样可以进一步配置它。

##### RemoveEntry的实现

​	注意的点是用了一下迭代器+循环遍历，这里不能直接for Instance应该是因为数组不能去遍历出Entry的内部成员，但是为什么不直接for Entry？？？不可以嘛?**还是因为不用迭代器不能调用RemoveCurrent？**应该是这样，需要用迭代器去删除遍历到的目标。

```c++
void FLyraInventoryList::RemoveEntry(ULyraInventoryItemInstance* Instance)
{
    for (auto EntryIt = Entries.CreateIterator(); EntryIt; ++EntryIt)
    {
       FLyraInventoryEntry& Entry = *EntryIt;
       if (Entry.Instance == Instance)
       {
          EntryIt.RemoveCurrent();
          MarkArrayDirty();
       }
    }
}
```

##### GetAllItems

此外InventoryList还有一个GetAllItems用来获得包含所有Instance的一个数组

```c++
TArray<ULyraInventoryItemInstance*> FLyraInventoryList::GetAllItems() const
{
    TArray<ULyraInventoryItemInstance*> Results;
    Results.Reserve(Entries.Num());
    for (const FLyraInventoryEntry& Entry : Entries)
    {
       if (Entry.Instance != nullptr) //@TODO: Would prefer to not deal with this here and hide it further?
       {
          Results.Add(Entry.Instance);
       }
    }
    return Results;
}
```

​	Reserve是用来开辟空间的。



#### 1.1.3 InventoryManagerComponent

.h

```c++
/**
 * Manages an inventory
 */
UCLASS(BlueprintType)
class LYRAGAME_API ULyraInventoryManagerComponent : public UActorComponent
{
	GENERATED_BODY()

public:
	ULyraInventoryManagerComponent(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category=Inventory)
	bool CanAddItemDefinition(TSubclassOf<ULyraInventoryItemDefinition> ItemDef, int32 StackCount = 1);

	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category=Inventory)
	ULyraInventoryItemInstance* AddItemDefinition(TSubclassOf<ULyraInventoryItemDefinition> ItemDef, int32 StackCount = 1);

	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category=Inventory)
	void AddItemInstance(ULyraInventoryItemInstance* ItemInstance);

	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category=Inventory)
	void RemoveItemInstance(ULyraInventoryItemInstance* ItemInstance);

	UFUNCTION(BlueprintCallable, Category=Inventory, BlueprintPure=false)
	TArray<ULyraInventoryItemInstance*> GetAllItems() const;

	UFUNCTION(BlueprintCallable, Category=Inventory, BlueprintPure)
	ULyraInventoryItemInstance* FindFirstItemStackByDefinition(TSubclassOf<ULyraInventoryItemDefinition> ItemDef) const;

	int32 GetTotalItemCountByDefinition(TSubclassOf<ULyraInventoryItemDefinition> ItemDef) const;
	bool ConsumeItemsByDefinition(TSubclassOf<ULyraInventoryItemDefinition> ItemDef, int32 NumToConsume);

	//~UObject interface
	virtual bool ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
	virtual void ReadyForReplication() override;
	//~End of UObject interface

private:
	UPROPERTY(Replicated)
	FLyraInventoryList InventoryList;
};
```

##### 几乎完全没做的CanAddItemDefinition……

```c++
bool ULyraInventoryManagerComponent::CanAddItemDefinition(TSubclassOf<ULyraInventoryItemDefinition> ItemDef, int32 StackCount)
{
    //@TODO: Add support for stack limit / uniqueness checks / etc...
    return true;
}
```

##### AddItemDefinition和实际上没用的AddItemInstance

​	AddItemDefinition本质的功能就是调用了一下InventoryList的AddEntry，RemoveItemDefinition同理。

```c++
ULyraInventoryItemInstance* ULyraInventoryManagerComponent::AddItemDefinition(TSubclassOf<ULyraInventoryItemDefinition> ItemDef, int32 StackCount)
{
    ULyraInventoryItemInstance* Result = nullptr;
    if (ItemDef != nullptr)
    {
       Result = InventoryList.AddEntry(ItemDef, StackCount);
       
       if (IsUsingRegisteredSubObjectList() && IsReadyForReplication() && Result)
       {
          AddReplicatedSubObject(Result);
       }
    }
    return Result;
}

void ULyraInventoryManagerComponent::AddItemInstance(ULyraInventoryItemInstance* ItemInstance)
{
    //这个AddEntry没有实现，所以这个函数屁用没有
    InventoryList.AddEntry(ItemInstance);
    if (IsUsingRegisteredSubObjectList() && IsReadyForReplication() && ItemInstance)
    {
       AddReplicatedSubObject(ItemInstance);
    }
}
```

##### RemoveItemDefinition

```c++
void ULyraInventoryManagerComponent::RemoveItemInstance(ULyraInventoryItemInstance* ItemInstance)
{
    InventoryList.RemoveEntry(ItemInstance);

    if (ItemInstance && IsUsingRegisteredSubObjectList())
    {
       RemoveReplicatedSubObject(ItemInstance);
    }
}
```

​	这两个没太多说的。

```c++
ULyraInventoryItemInstance* ULyraInventoryManagerComponent::FindFirstItemStackByDefinition(TSubclassOf<ULyraInventoryItemDefinition> ItemDef) const
{
    for (const FLyraInventoryEntry& Entry : InventoryList.Entries)
    {
       ULyraInventoryItemInstance* Instance = Entry.Instance;

       if (IsValid(Instance))
       {
          if (Instance->GetItemDef() == ItemDef)
          {
             return Instance;
          }
       }
    }

    return nullptr;
}

int32 ULyraInventoryManagerComponent::GetTotalItemCountByDefinition(TSubclassOf<ULyraInventoryItemDefinition> ItemDef) const
{
    int32 TotalCount = 0;
    for (const FLyraInventoryEntry& Entry : InventoryList.Entries)
    {
       ULyraInventoryItemInstance* Instance = Entry.Instance;

       if (IsValid(Instance))
       {
          if (Instance->GetItemDef() == ItemDef)
          {
             ++TotalCount;
          }
       }
    }

    return TotalCount;
}
```

##### ConsumeItemsByDefinition

​	Lyra的物品栏的消耗逻辑比较特别，由于Lyra是一个射击游戏，它好像是不太在乎物品栏的物品的“槽位”的概念的，事实上好像确实是这样。从这里可以看出LyraInventory每次获得了物品，视作为新增了一个“Entry”，类似于一个进账记录，每条记录会记录一下这条进账获得了多少某个品类的东西。这也可以说明为什么LyraInventory选择使用TArray而不是Map，因为Lyra不关心“槽位”的概念，Lyra只关心“有什么”和“有多少”的概念。因此Lyra中消耗某种Item的方式是遍历List，在完成目标消耗指标之前一直去“消耗”遇到的Entry。

​	要注意的是，这里的消耗Entry是消耗整个Entry包含的Item，而不是消耗Item中的几个，例如一条Entry中维护了“子弹”*50，ConsumeItem就会直接把这整条Entry消耗掉而不是消耗50发弹药中的若干发。

​	Item的实际数量由ItemInstance中的StatTag维护，所以Item的实际数量的增删的逻辑在ItemInstance中，我们接下来就去看ItemInstance。

```c++
bool ULyraInventoryManagerComponent::ConsumeItemsByDefinition(TSubclassOf<ULyraInventoryItemDefinition> ItemDef, int32 NumToConsume)
{
    AActor* OwningActor = GetOwner();
    if (!OwningActor || !OwningActor->HasAuthority())
    {
       return false;
    }

    //@TODO: N squared right now as there's no acceleration structure
    int32 TotalConsumed = 0;
    while (TotalConsumed < NumToConsume)
    {
       if (ULyraInventoryItemInstance* Instance = ULyraInventoryManagerComponent::FindFirstItemStackByDefinition(ItemDef))
       {
          InventoryList.RemoveEntry(Instance);
          ++TotalConsumed;
       }
       else
       {
          return false;
       }
    }

    return TotalConsumed == NumToConsume;
}
```

### 1.2 LyraInventoryItemInstance

#### 1.2.1 LyraInventoryItemInstance

LyraInventoryItemInstance.h

```c++
#include "System/GameplayTagStack.h"
#include "Templates/SubclassOf.h"

#include "LyraInventoryItemInstance.generated.h"

class FLifetimeProperty;

class ULyraInventoryItemDefinition;
class ULyraInventoryItemFragment;
struct FFrame;
struct FGameplayTag;

/**
 * ULyraInventoryItemInstance
 */
UCLASS(BlueprintType)
class ULyraInventoryItemInstance : public UObject
{
    GENERATED_BODY()

public:
    ULyraInventoryItemInstance(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

    //~UObject interface
    virtual bool IsSupportedForNetworking() const override { return true; }
    //~End of UObject interface

    // Adds a specified number of stacks to the tag (does nothing if StackCount is below 1)
    UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category=Inventory)
    void AddStatTagStack(FGameplayTag Tag, int32 StackCount);

    // Removes a specified number of stacks from the tag (does nothing if StackCount is below 1)
    UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category= Inventory)
    void RemoveStatTagStack(FGameplayTag Tag, int32 StackCount);

    // Returns the stack count of the specified tag (or 0 if the tag is not present)
    UFUNCTION(BlueprintCallable, Category=Inventory)
    int32 GetStatTagStackCount(FGameplayTag Tag) const;

    // Returns true if there is at least one stack of the specified tag
    UFUNCTION(BlueprintCallable, Category=Inventory)
    bool HasStatTag(FGameplayTag Tag) const;

    TSubclassOf<ULyraInventoryItemDefinition> GetItemDef() const
    {
       return ItemDef;
    }

    UFUNCTION(BlueprintCallable, BlueprintPure=false, meta=(DeterminesOutputType=FragmentClass))
    const ULyraInventoryItemFragment* FindFragmentByClass(TSubclassOf<ULyraInventoryItemFragment> FragmentClass) const;

    template <typename ResultClass>
    const ResultClass* FindFragmentByClass() const
    {
       return (ResultClass*)FindFragmentByClass(ResultClass::StaticClass());
    }

private:
#if UE_WITH_IRIS
    /** Register all replication fragments */
    virtual void RegisterReplicationFragments(UE::Net::FFragmentRegistrationContext& Context, UE::Net::EFragmentRegistrationFlags RegistrationFlags) override;
#endif // UE_WITH_IRIS

    void SetItemDef(TSubclassOf<ULyraInventoryItemDefinition> InDef);

    friend struct FLyraInventoryList;

private:
    UPROPERTY(Replicated)
    FGameplayTagStackContainer StatTags;

    // The item definition
    UPROPERTY(Replicated)
    TSubclassOf<ULyraInventoryItemDefinition> ItemDef;
};
```

​	ItemInstance实际上主要维护了一个ItemDefinition和一个StatTags（FGameplayTagStackContainer），基本上ItemInstance的StatCount的增减都是通过FGameplayTagStackContainer的方法。

```c++
#include "LyraInventoryItemInstance.h"

#include "Inventory/LyraInventoryItemDefinition.h"
#include "Net/UnrealNetwork.h"

#if UE_WITH_IRIS
#include "Iris/ReplicationSystem/ReplicationFragmentUtil.h"
#endif // UE_WITH_IRIS

#include UE_INLINE_GENERATED_CPP_BY_NAME(LyraInventoryItemInstance)

class FLifetimeProperty;

ULyraInventoryItemInstance::ULyraInventoryItemInstance(const FObjectInitializer& ObjectInitializer)
    : Super(ObjectInitializer)
{
}

void ULyraInventoryItemInstance::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
    Super::GetLifetimeReplicatedProps(OutLifetimeProps);

    DOREPLIFETIME(ThisClass, StatTags);
    DOREPLIFETIME(ThisClass, ItemDef);
}

#if UE_WITH_IRIS
void ULyraInventoryItemInstance::RegisterReplicationFragments(UE::Net::FFragmentRegistrationContext& Context, UE::Net::EFragmentRegistrationFlags RegistrationFlags)
{
    using namespace UE::Net;

    // Build descriptors and allocate PropertyReplicationFragments for this object
    FReplicationFragmentUtil::CreateAndRegisterFragmentsForObject(this, Context, RegistrationFlags);
}
#endif // UE_WITH_IRIS

void ULyraInventoryItemInstance::AddStatTagStack(FGameplayTag Tag, int32 StackCount)
{
    StatTags.AddStack(Tag, StackCount);
}

void ULyraInventoryItemInstance::RemoveStatTagStack(FGameplayTag Tag, int32 StackCount)
{
    StatTags.RemoveStack(Tag, StackCount);
}

int32 ULyraInventoryItemInstance::GetStatTagStackCount(FGameplayTag Tag) const
{
    return StatTags.GetStackCount(Tag);
}

bool ULyraInventoryItemInstance::HasStatTag(FGameplayTag Tag) const
{
    return StatTags.ContainsTag(Tag);
}

void ULyraInventoryItemInstance::SetItemDef(TSubclassOf<ULyraInventoryItemDefinition> InDef)
{
    ItemDef = InDef;
}

const ULyraInventoryItemFragment* ULyraInventoryItemInstance::FindFragmentByClass(TSubclassOf<ULyraInventoryItemFragment> FragmentClass) const
{
    if ((ItemDef != nullptr) && (FragmentClass != nullptr))
    {
       return GetDefault<ULyraInventoryItemDefinition>(ItemDef)->FindFragmentByClass(FragmentClass);
    }

    return nullptr;
}
```

​	通过Rider的查看函数蓝图用法可以发现LyraItemInstance的StatTag的增删要么就是“换弹”要么就是“捡到补充弹药”，所以LyraItem其中一种就是“弹药”。

​	既然ItemInstance的数量是靠GameplayTagStack维护的，那么我们再来看一看它。

#### 1.2.2 GameplayTagStack

GameplayTagStack.h

```c++
#include "GameplayTagContainer.h"
#include "Net/Serialization/FastArraySerializer.h"

#include "GameplayTagStack.generated.h"

struct FGameplayTagStackContainer;
struct FNetDeltaSerializeInfo;

/**
 * Represents one stack of a gameplay tag (tag + count)
 */
USTRUCT(BlueprintType)
struct FGameplayTagStack : public FFastArraySerializerItem
{
    GENERATED_BODY()

    FGameplayTagStack()
    {}

    FGameplayTagStack(FGameplayTag InTag, int32 InStackCount)
       : Tag(InTag)
       , StackCount(InStackCount)
    {
    }

    FString GetDebugString() const;

private:
    friend FGameplayTagStackContainer;

    UPROPERTY()
    FGameplayTag Tag;

    UPROPERTY()
    int32 StackCount = 0;
};

/** Container of gameplay tag stacks */
USTRUCT(BlueprintType)
struct FGameplayTagStackContainer : public FFastArraySerializer
{
    GENERATED_BODY()

    FGameplayTagStackContainer()
    // : Owner(nullptr)
    {
    }

public:
    // Adds a specified number of stacks to the tag (does nothing if StackCount is below 1)
    void AddStack(FGameplayTag Tag, int32 StackCount);

    // Removes a specified number of stacks from the tag (does nothing if StackCount is below 1)
    void RemoveStack(FGameplayTag Tag, int32 StackCount);

    // Returns the stack count of the specified tag (or 0 if the tag is not present)
    int32 GetStackCount(FGameplayTag Tag) const
    {
       return TagToCountMap.FindRef(Tag);
    }

    // Returns true if there is at least one stack of the specified tag
    bool ContainsTag(FGameplayTag Tag) const
    {
       return TagToCountMap.Contains(Tag);
    }

    //~FFastArraySerializer contract
    void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
    void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
    void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
    //~End of FFastArraySerializer contract

    bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
    {
       return FFastArraySerializer::FastArrayDeltaSerialize<FGameplayTagStack, FGameplayTagStackContainer>(Stacks, DeltaParms, *this);
    }

private:
    // Replicated list of gameplay tag stacks
    UPROPERTY()
    TArray<FGameplayTagStack> Stacks;
    
    // Accelerated list of tag stacks for queries
    TMap<FGameplayTag, int32> TagToCountMap;
};

template<>
struct TStructOpsTypeTraits<FGameplayTagStackContainer> : public TStructOpsTypeTraitsBase2<FGameplayTagStackContainer>
{
    enum
    {
       WithNetDeltaSerializer = true,
    };
};
```

​	一个GameplayTagStack是一个结构体，本质上维护了一个GameplayTag和一个StackCount（int32），

##### AddStack

```c++
// FGameplayTagStackContainer

void FGameplayTagStackContainer::AddStack(FGameplayTag Tag, int32 StackCount)
{
    if (!Tag.IsValid())
    {
       FFrame::KismetExecutionMessage(TEXT("An invalid tag was passed to AddStack"), ELogVerbosity::Warning);
       return;
    }

    if (StackCount > 0)
    {
       for (FGameplayTagStack& Stack : Stacks)
       {
          if (Stack.Tag == Tag)
          {
             const int32 NewCount = Stack.StackCount + StackCount;
             Stack.StackCount = NewCount;
             TagToCountMap[Tag] = NewCount;
             MarkItemDirty(Stack);
             return;
          }
       }

       FGameplayTagStack& NewStack = Stacks.Emplace_GetRef(Tag, StackCount);
       MarkItemDirty(NewStack);
       TagToCountMap.Add(Tag, StackCount);
    }
}
```

​	根据当前StackContainer中是否已有Stack来决定是新增一个Stack还是直接增加Stack的StackCount。

##### RemoveStack

```c++
void FGameplayTagStackContainer::RemoveStack(FGameplayTag Tag, int32 StackCount)
{
    if (!Tag.IsValid())
    {
       FFrame::KismetExecutionMessage(TEXT("An invalid tag was passed to RemoveStack"), ELogVerbosity::Warning);
       return;
    }

    //@TODO: Should we error if you try to remove a stack that doesn't exist or has a smaller count?
    if (StackCount > 0)
    {
       for (auto It = Stacks.CreateIterator(); It; ++It)
       {
          FGameplayTagStack& Stack = *It;
          if (Stack.Tag == Tag)
          {
             if (Stack.StackCount <= StackCount)
             {
                It.RemoveCurrent();
                TagToCountMap.Remove(Tag);
                MarkArrayDirty();
             }
             else
             {
                const int32 NewCount = Stack.StackCount - StackCount;
                Stack.StackCount = NewCount;
                TagToCountMap[Tag] = NewCount;
                MarkItemDirty(Stack);
             }
             return;
          }
       }
    }
}
```

​	用迭代器估计是为了可以在遍历的时候动态删除。

​	貌似一个ItemInstance实际上可以允许有不同的Tag进入？那这个Item怎么保证单纯？

​	带着这个疑惑，我搜索了GameplayTagStack的用法，发现它不仅仅用在InventoryItemInstance中，还用在了PlayerState和Team中，说明这个东西是一物多用了，所以它带有的一些功能在ItemInstance中看起来格格不入，应该是服务于更泛用的场景。

​	所以ItemInctance应该算是借用了这个东西来计算Stack，因为这个东西继承了FFastArraySerializer，应该是方便网络复制相关的东西。

​	实际上一个ItemInstance在使用的过程中应该永远只会有一种Tag，TagtoCount这个Map实际上也只有一个元素。

> [!NOTE]
>
> ​	后来我想通了一个很鸡贼的点，就是一个Item的Instance中的StackCount并不是代表其自己有多少，而是可以代表别的东西有多少，例如对于枪来说，就是有多少弹药，所以根本不会有实体的弹药Item出现在玩家的Inventory，而是弹药以Tag的形式出现在了ItemInstance的Stacks中。真正代表一个Item有多少的应该还是Entry中的StackCount，但是由于Lyra的进Inventory的Item基本上都是“武器”，所以都是不可堆叠的一个一个的，显得Entry的StackCount似乎作用不大。

​	接下来再看InventoryItemDefinition。

#### 1.2.3 LyraItemDefinition

.h

```c++
#include "Kismet/BlueprintFunctionLibrary.h"

#include "LyraInventoryItemDefinition.generated.h"

template <typename T> class TSubclassOf;

class ULyraInventoryItemInstance;
struct FFrame;

//////////////////////////////////////////////////////////////////////

// Represents a fragment of an item definition
UCLASS(DefaultToInstanced, EditInlineNew, Abstract)
class LYRAGAME_API ULyraInventoryItemFragment : public UObject
{
    GENERATED_BODY()

public:
    virtual void OnInstanceCreated(ULyraInventoryItemInstance* Instance) const {}
};

//////////////////////////////////////////////////////////////////////

/**
 * ULyraInventoryItemDefinition
 */
UCLASS(Blueprintable, Const, Abstract)
class ULyraInventoryItemDefinition : public UObject
{
    GENERATED_BODY()

public:
    ULyraInventoryItemDefinition(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category=Display)
    FText DisplayName;

    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category=Display, Instanced)
    TArray<TObjectPtr<ULyraInventoryItemFragment>> Fragments;

public:
    const ULyraInventoryItemFragment* FindFragmentByClass(TSubclassOf<ULyraInventoryItemFragment> FragmentClass) const;
};

//@TODO: Make into a subsystem instead?
UCLASS()
class ULyraInventoryFunctionLibrary : public UBlueprintFunctionLibrary
{
    GENERATED_BODY()

    UFUNCTION(BlueprintCallable, meta=(DeterminesOutputType=FragmentClass))
    static const ULyraInventoryItemFragment* FindItemDefinitionFragment(TSubclassOf<ULyraInventoryItemDefinition> ItemDef, TSubclassOf<ULyraInventoryItemFragment> FragmentClass);
};
```

​	先直接看ItemDefinition内部。

​	首先ItemDefinition继承自UObject，出身比较简单。

​	ItemDefinition本身也相当简单，其中只维护了一个FText DisplayName和一个Fragment的TArray。

​	再结合Fragment本身来看，其本体相当简单，继承自UObject没有任何属性，只有一个没有实现方法OnInstanceCreated，由于给派生的子类去定义，Fragment本身只是起到一个父类继承的意义，其真正的东西都在自己的诸多子类中。

​	Definition相关的方法，主要就是去找Fragment。

```c++
const ULyraInventoryItemFragment* ULyraInventoryItemDefinition::FindFragmentByClass(TSubclassOf<ULyraInventoryItemFragment> FragmentClass) const
{
    if (FragmentClass != nullptr)
    {
       for (ULyraInventoryItemFragment* Fragment : Fragments)
       {
          if (Fragment && Fragment->IsA(FragmentClass))
          {
             return Fragment;
          }
       }
    }

    return nullptr;
}

//////////////////////////////////////////////////////////////////////
// ULyraInventoryItemDefinition

const ULyraInventoryItemFragment* ULyraInventoryFunctionLibrary::FindItemDefinitionFragment(TSubclassOf<ULyraInventoryItemDefinition> ItemDef, TSubclassOf<ULyraInventoryItemFragment> FragmentClass)
{
    if ((ItemDef != nullptr) && (FragmentClass != nullptr))
    {
       return GetDefault<ULyraInventoryItemDefinition>(ItemDef)->FindFragmentByClass(FragmentClass);
    }
    return nullptr;
}
```

##### Fragment

​	可以说实际上ItemDefinition就是一堆Fragment的包装盒，真正有用的信息都在Fragment中，而定义一个ItemDefinition的时候，就可以**选择性地**给ItemDefinition添加需要的Fragment信息，例如装备图标、弹夹容量等等。

​	简单在Rider中查找一下Definition中的DisplayName的更改的地方，就能找到几个被定义好的ItemDefinition，例如这是“Pistol”的Definition，其中我们还可以看到EquipmentDefinition，待会我们再去看EquipmentDefinition和ItemDefinition的联系与差别。

​	可以看到，通过一个TArray<Fragment>加Fragment派生子类的组合拳，ItemDefinition实现了很灵活很清晰的物品信息配置。

​	暂时先不要去看其他的内容，不然就出不来了，我们目前只需知道ItemDefinition实现了很不错的效果即可。

![image-20250129095655127](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250129095655127.png)

​	基本上Fragment的各个子类就是表明了各种物品可能有的信息，比较简单。

​	例如这是UInventoryFragment_EquippableItem的定义，注意到它没有重写OnInstanceCreated.

​	EquippableItem就是提供了一个ULyraEquipmentDefinition的信息。

```c++
class ULyraEquipmentDefinition;
class UObject;

UCLASS()
class UInventoryFragment_EquippableItem : public ULyraInventoryItemFragment
{
    GENERATED_BODY()

public:
    UPROPERTY(EditAnywhere, Category=Lyra)
    TSubclassOf<ULyraEquipmentDefinition> EquipmentDefinition;
};
```

​	而SetStat中有重写OnInstanceCreated，可以见得它有更多的“功能”。

.h

```c++
class ULyraInventoryItemInstance;
class UObject;
struct FGameplayTag;

UCLASS()
class UInventoryFragment_SetStats : public ULyraInventoryItemFragment
{
    GENERATED_BODY()

protected:
    UPROPERTY(EditDefaultsOnly, Category=Equipment)
    TMap<FGameplayTag, int32> InitialItemStats;

public:
    virtual void OnInstanceCreated(ULyraInventoryItemInstance* Instance) const override;

    int32 GetItemStatByTag(FGameplayTag Tag) const;
```

.cpp

```c++
void UInventoryFragment_SetStats::OnInstanceCreated(ULyraInventoryItemInstance* Instance) const
{
    for (const auto& KVP : InitialItemStats)
    {
       Instance->AddStatTagStack(KVP.Key, KVP.Value);
    }
}

int32 UInventoryFragment_SetStats::GetItemStatByTag(FGameplayTag Tag) const
{
    if (const int32* StatPtr = InitialItemStats.Find(Tag))
    {
       return *StatPtr;
    }

    return 0;
}
```

​	OnInstanceCreated方法提供了一个初始化Item中的弹药的方法。

​	而OnInstanceCreated方法在InventoryManagerComponent的AddEntry中被使用到：

![image-20250129105033998](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250129105033998.png)

​	结合ID_Pistol的Stat可以了解其初始化的方法。

![image-20250129105248364](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250129105248364.png)

![image-20250129105201830](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250129105201830.png)

​	可以看出，SetStat实际上是通过了各种Tag配合一个整数，来实现了定义Pistol的弹匣容量、初始化了弹匣中子弹数量和武器的现有剩余弹药。这一点非常聪明。在玩家获得一个新的Item，也就是InventoryManagerComponent的InventoryList进行一次AddEntry时，就会调用ItemDefinition中的每一条Fragment的OnInstanceCreated方法（如果有实现的话），这样就完成了对Item的Stack等信息的初始化。

##### Pickuppable

​	值得注意的是，Lyra中的Pickup武器其实不是实际意义上的”拾取“了”武器“，而是通过B_WeaponSpawner的碰撞检测体积的OnOverlapBegin委托，通过对进入碰撞体积的Pawn执行AttemptPickUpWeapon_Implementation，试图对其GiveWeapon。所以并不是依靠一个游戏中的Weapon的掉落物实体和Pawn的交互实现的获取一个Weapon。

LyraWeaponSpawner的一些相关的函数实现：

```c++
void ALyraWeaponSpawner::OnOverlapBegin(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepHitResult)
{
    APawn* OverlappingPawn = Cast<APawn>(OtherActor);
    if (GetLocalRole() == ROLE_Authority && bIsWeaponAvailable && OverlappingPawn != nullptr)
    {
       AttemptPickUpWeapon(OverlappingPawn);
    }
}
```

```c++
void ALyraWeaponSpawner::AttemptPickUpWeapon_Implementation(APawn* Pawn)
{
    if (GetLocalRole() == ROLE_Authority && bIsWeaponAvailable && UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Pawn))
    {
       TSubclassOf<ULyraInventoryItemDefinition> WeaponItemDefinition = WeaponDefinition ? WeaponDefinition->InventoryItemDefinition : nullptr;
       if (WeaponItemDefinition != nullptr)
       {
          //Attempt to grant the weapon
          if (GiveWeapon(WeaponItemDefinition, Pawn))
          {
             //Weapon picked up by pawn
             bIsWeaponAvailable = false;
             SetWeaponPickupVisibility(false);
             PlayPickupEffects();
             StartCoolDown();
          }
       }     
    }
}
```

​	此外，貌似每个WeaponSpawner能够产生的Weapon种类是固定的，其只持有了一个TSubClassOf<ULyraInventoryItemDefinition>，没有啥随机性。

​	再者，WeaponSpawner基本上就是一个用来制造一个武器产生点位的简单的Actor，没有太多特别之处。

​	

​	Lyra中真正实现了Pickupable的东西只有两个用来做测试的东西，它们在ShooterExplorer/Content/Items中，但是这两个东西的实际交互貌似是没有做完的，虽然可以和其进行交互（例如B_InteractableRock可以被捡起来），但是实际上并不能将其收入物品栏，物品栏UI中的显示也是没做完的。具体原因：[garashka.github.io](https://garashka.github.io/LyraDocs/lyra/fixing-inventory-system.html)

​	这两个“可拾取物”继承自LyraWorldCollectable，这是一个比较简单的用来实现“拾取”逻辑的Actor，其继承了IPickupable接口和IInteractableTarget接口。主要是靠子类实现接口来实现“**可被拾取”**和**“可添加Item实例到玩家Inventory”**的机制，LyraWorldCollectable连StaticMesh都没有提供，全靠子类补充。

​	子类实现IInteractableTarget接口主要是为了实现“主动地拾取”的机制，这点涉及到Lyra的交互，具体的交互逻辑在PART IV展开。

LyraWorldCollectable.h

```c++
#include "GameFramework/Actor.h"
#include "Interaction/IInteractableTarget.h"
#include "Interaction/InteractionOption.h"
#include "Inventory/IPickupable.h"

#include "LyraWorldCollectable.generated.h"

class UObject;
struct FInteractionQuery;

/**
 * 
 */
UCLASS(Abstract, Blueprintable)
class ALyraWorldCollectable : public AActor, public IInteractableTarget, public IPickupable
{
    GENERATED_BODY()

public:

    ALyraWorldCollectable();

    virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& InteractionBuilder) override;
    virtual FInventoryPickup GetPickupInventory() const override;

protected:
    UPROPERTY(EditAnywhere)
    FInteractionOption Option;

    UPROPERTY(EditAnywhere)
    FInventoryPickup StaticInventory;
};
```

IPickupable.h

```c++
#include "Kismet/BlueprintFunctionLibrary.h"
#include "Templates/SubclassOf.h"
#include "UObject/Interface.h"

#include "UObject/ObjectPtr.h"
#include "IPickupable.generated.h"

template <typename InterfaceType> class TScriptInterface;

class AActor;
class ULyraInventoryItemDefinition;
class ULyraInventoryItemInstance;
class ULyraInventoryManagerComponent;
class UObject;
struct FFrame;

USTRUCT(BlueprintType)
struct FPickupTemplate
{
    GENERATED_BODY()

public:
    UPROPERTY(EditAnywhere)
    int32 StackCount = 1;

    UPROPERTY(EditAnywhere)
    TSubclassOf<ULyraInventoryItemDefinition> ItemDef;
};

USTRUCT(BlueprintType)
struct FPickupInstance
{
    GENERATED_BODY()

public:
    UPROPERTY(EditAnywhere, BlueprintReadOnly)
    TObjectPtr<ULyraInventoryItemInstance> Item = nullptr;
};

USTRUCT(BlueprintType)
struct FInventoryPickup
{
    GENERATED_BODY()

public:
    UPROPERTY(EditAnywhere, BlueprintReadOnly)
    TArray<FPickupInstance> Instances;

    UPROPERTY(EditAnywhere, BlueprintReadOnly)
    TArray<FPickupTemplate> Templates;
};

/**  */
UINTERFACE(MinimalAPI, BlueprintType, meta = (CannotImplementInterfaceInBlueprint))
class UPickupable : public UInterface
{
    GENERATED_BODY()
};

/**  */
class IPickupable
{
    GENERATED_BODY()

public:
    UFUNCTION(BlueprintCallable)
    virtual FInventoryPickup GetPickupInventory() const = 0;
};

/**  */
UCLASS()
class UPickupableStatics : public UBlueprintFunctionLibrary
{
    GENERATED_BODY()

public:
    UPickupableStatics();

public:
    UFUNCTION(BlueprintPure)
    static TScriptInterface<IPickupable> GetFirstPickupableFromActor(AActor* Actor);

    UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, meta = (WorldContext = "Ability"))
    static void AddPickupToInventory(ULyraInventoryManagerComponent* InventoryComponent, TScriptInterface<IPickupable> Pickup);
};
```







## 2. LyraEquipment

​	现在再来看一下和Item很相似的Equipment。

.h

```c++
#include "AbilitySystem/LyraAbilitySet.h"
#include "Components/PawnComponent.h"
#include "Net/Serialization/FastArraySerializer.h"

#include "LyraEquipmentManagerComponent.generated.h"

class UActorComponent;
class ULyraAbilitySystemComponent;
class ULyraEquipmentDefinition;
class ULyraEquipmentInstance;
class ULyraEquipmentManagerComponent;
class UObject;
struct FFrame;
struct FLyraEquipmentList;
struct FNetDeltaSerializeInfo;
struct FReplicationFlags;

/** A single piece of applied equipment */
USTRUCT(BlueprintType)
struct FLyraAppliedEquipmentEntry : public FFastArraySerializerItem
{
    GENERATED_BODY()

    FLyraAppliedEquipmentEntry()
    {}

    FString GetDebugString() const;

private:
    friend FLyraEquipmentList;
    friend ULyraEquipmentManagerComponent;

    // The equipment class that got equipped
    UPROPERTY()
    TSubclassOf<ULyraEquipmentDefinition> EquipmentDefinition;

    UPROPERTY()
    TObjectPtr<ULyraEquipmentInstance> Instance = nullptr;

    // Authority-only list of granted handles
    UPROPERTY(NotReplicated)
    FLyraAbilitySet_GrantedHandles GrantedHandles;
};

/** List of applied equipment */
USTRUCT(BlueprintType)
struct FLyraEquipmentList : public FFastArraySerializer
{
    GENERATED_BODY()

    FLyraEquipmentList()
       : OwnerComponent(nullptr)
    {
    }

    FLyraEquipmentList(UActorComponent* InOwnerComponent)
       : OwnerComponent(InOwnerComponent)
    {
    }

public:
    //~FFastArraySerializer contract
    void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
    void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
    void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
    //~End of FFastArraySerializer contract

    bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
    {
       return FFastArraySerializer::FastArrayDeltaSerialize<FLyraAppliedEquipmentEntry, FLyraEquipmentList>(Entries, DeltaParms, *this);
    }

    ULyraEquipmentInstance* AddEntry(TSubclassOf<ULyraEquipmentDefinition> EquipmentDefinition);
    void RemoveEntry(ULyraEquipmentInstance* Instance);

private:
    ULyraAbilitySystemComponent* GetAbilitySystemComponent() const;

    friend ULyraEquipmentManagerComponent;

private:
    // Replicated list of equipment entries
    UPROPERTY()
    TArray<FLyraAppliedEquipmentEntry> Entries;

    UPROPERTY(NotReplicated)
    TObjectPtr<UActorComponent> OwnerComponent;
};

template<>
struct TStructOpsTypeTraits<FLyraEquipmentList> : public TStructOpsTypeTraitsBase2<FLyraEquipmentList>
{
    enum { WithNetDeltaSerializer = true };
};










/**
 * Manages equipment applied to a pawn
 */
UCLASS(BlueprintType, Const)
class LYRAGAME_API ULyraEquipmentManagerComponent : public UPawnComponent
{
    GENERATED_BODY()

public:
    ULyraEquipmentManagerComponent(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

    UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly)
    ULyraEquipmentInstance* EquipItem(TSubclassOf<ULyraEquipmentDefinition> EquipmentDefinition);

    UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly)
    void UnequipItem(ULyraEquipmentInstance* ItemInstance);

    //~UObject interface
    virtual bool ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
    //~End of UObject interface

    //~UActorComponent interface
    //virtual void EndPlay() override;
    virtual void InitializeComponent() override;
    virtual void UninitializeComponent() override;
    virtual void ReadyForReplication() override;
    //~End of UActorComponent interface

    /** Returns the first equipped instance of a given type, or nullptr if none are found */
    UFUNCTION(BlueprintCallable, BlueprintPure)
    ULyraEquipmentInstance* GetFirstInstanceOfType(TSubclassOf<ULyraEquipmentInstance> InstanceType);

    /** Returns all equipped instances of a given type, or an empty array if none are found */
    UFUNCTION(BlueprintCallable, BlueprintPure)
    TArray<ULyraEquipmentInstance*> GetEquipmentInstancesOfType(TSubclassOf<ULyraEquipmentInstance> InstanceType) const;

    template <typename T>
    T* GetFirstInstanceOfType()
    {
       return (T*)GetFirstInstanceOfType(T::StaticClass());
    }

private:
    UPROPERTY(Replicated)
    FLyraEquipmentList EquipmentList;
};
```

### 2.1 EquipmentManagerComponent

​	LyraEquipmentManagerComponent由Pawn拥有。

#### 2.1.1 Entry与EquipmentInstance和EquipmentDefinition

```c++
/** A single piece of applied equipment */
USTRUCT(BlueprintType)
struct FLyraAppliedEquipmentEntry : public FFastArraySerializerItem
{
    GENERATED_BODY()

    FLyraAppliedEquipmentEntry()
    {}

    FString GetDebugString() const;

private:
    friend FLyraEquipmentList;
    friend ULyraEquipmentManagerComponent;

    // The equipment class that got equipped
    UPROPERTY()
    TSubclassOf<ULyraEquipmentDefinition> EquipmentDefinition;

    UPROPERTY()
    TObjectPtr<ULyraEquipmentInstance> Instance = nullptr;

    // Authority-only list of granted handles
    UPROPERTY(NotReplicated)
    FLyraAbilitySet_GrantedHandles GrantedHandles;
};
```

##### EquipmentInstance

​	EquipmentManagerComponent中的Entry和Inventory有相似之处也有不同，不同之处在于Entry维护多了一个EquipmentDefinition而没有Count。值得注意的是，Equipment的Instance和Inventory的Instance有点不同 ，Inventory的Instance更多是意在维护一个Item实例的数量，而Equipment的Instance则完全不是这样，EquipmentManagerComponent中不需要研究一个Equipment“有多少”，它只研究“是否装备”，“有多少”是Inventory中管理的事情，EquipmentManager要做的就是明确一件Equipment的各项信息，因此，实际上EquipmentInstance还是一种**Definition**，针对不同的类型的Equipment派生出不同的属性。

​	EquipmentInstance先派生了一个C++类LyraWeaponInstance，再从这个类派生了LyraRangedWeaponInstance，其中新增了很多的属性，**逐步细化**了一把RangedWeapon应该要有的东西，然后派生成蓝图类的一个基类，再派生成其他的真正的武器数据，例如Pistol、Shotgun等等武器，属性有例如以下这些像有效伤害范围、伤害随距离衰减、子弹散布、装备或卸下的时候播放的蒙太奇等等。

![image-20250129145756756](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250129145756756.png)

![image-20250129145827793](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250129145827793.png)

##### **EquipmentDefinition**

​	EquipmentInstance实际上还是一种Definition，那么EquipmentDefinition是什么？

​	EquipmentDefinition其实是涵盖了EquipmentInstance的一个**更大的**一个Definition，它包含了一个EquipmentInstance，还有这个Equipment要赋予装备者的Ability的信息（AbilitySet），还有一个如何装备的信息的结构体（FLyraEquipmentActorToSpawn）。

```c++
#include "Templates/SubclassOf.h"

#include "LyraEquipmentDefinition.generated.h"

class AActor;
class ULyraAbilitySet;
class ULyraEquipmentInstance;

USTRUCT()
struct FLyraEquipmentActorToSpawn
{
    GENERATED_BODY()

    FLyraEquipmentActorToSpawn()
    {}

    UPROPERTY(EditAnywhere, Category=Equipment)
    TSubclassOf<AActor> ActorToSpawn;

    UPROPERTY(EditAnywhere, Category=Equipment)
    FName AttachSocket;

    UPROPERTY(EditAnywhere, Category=Equipment)
    FTransform AttachTransform;
};


/**
 * ULyraEquipmentDefinition
 *
 * Definition of a piece of equipment that can be applied to a pawn
 */
UCLASS(Blueprintable, Const, Abstract, BlueprintType)
class ULyraEquipmentDefinition : public UObject
{
    GENERATED_BODY()

public:
    ULyraEquipmentDefinition(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

    // Class to spawn
    UPROPERTY(EditDefaultsOnly, Category=Equipment)
    TSubclassOf<ULyraEquipmentInstance> InstanceType;

    // Gameplay ability sets to grant when this is equipped
    UPROPERTY(EditDefaultsOnly, Category=Equipment)
    TArray<TObjectPtr<const ULyraAbilitySet>> AbilitySetsToGrant;

    // Actors to spawn on the pawn when this is equipped
    UPROPERTY(EditDefaultsOnly, Category=Equipment)
    TArray<FLyraEquipmentActorToSpawn> ActorsToSpawn;
};
```

**例子：WID_Pistol中的各种配置：**

![image-20250129154040391](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250129154040391.png)

##### AddEntry的实现

```c++
ULyraEquipmentInstance* FLyraEquipmentList::AddEntry(TSubclassOf<ULyraEquipmentDefinition> EquipmentDefinition)
{
    ULyraEquipmentInstance* Result = nullptr;

    check(EquipmentDefinition != nullptr);
    check(OwnerComponent);
    check(OwnerComponent->GetOwner()->HasAuthority());
    
    const ULyraEquipmentDefinition* EquipmentCDO = GetDefault<ULyraEquipmentDefinition>(EquipmentDefinition);

    TSubclassOf<ULyraEquipmentInstance> InstanceType = EquipmentCDO->InstanceType;
    if (InstanceType == nullptr)
    {
       InstanceType = ULyraEquipmentInstance::StaticClass();
    }
    
    FLyraAppliedEquipmentEntry& NewEntry = Entries.AddDefaulted_GetRef();
    NewEntry.EquipmentDefinition = EquipmentDefinition;
    NewEntry.Instance = NewObject<ULyraEquipmentInstance>(OwnerComponent->GetOwner(), InstanceType);  //@TODO: Using the actor instead of component as the outer due to UE-127172
    Result = NewEntry.Instance;

    if (ULyraAbilitySystemComponent* ASC = GetAbilitySystemComponent())
    {
       for (const TObjectPtr<const ULyraAbilitySet>& AbilitySet : EquipmentCDO->AbilitySetsToGrant)
       {
          AbilitySet->GiveToAbilitySystem(ASC, /*inout*/ &NewEntry.GrantedHandles, Result);
       }
    }
    else
    {
       //@TODO: Warning logging?
    }

    Result->SpawnEquipmentActors(EquipmentCDO->ActorsToSpawn);


    MarkItemDirty(NewEntry);

    return Result;
}
```

​	可以关注到AddEntry还涉及到了把Equipment上的**“AbilitySet”**通过AbilitySet->GiveToAbilitySystem给授予这个装备者的ASC。AbilitySet实际上是一个PrimaryDataAsset，里面维护了三个和GAS相关的属性：

```c++
/**
 * ULyraAbilitySet
 *
 *  Non-mutable data asset used to grant gameplay abilities and gameplay effects.
 */
UCLASS(BlueprintType, Const)
class ULyraAbilitySet : public UPrimaryDataAsset
{
    GENERATED_BODY()

public:

    ULyraAbilitySet(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

    // Grants the ability set to the specified ability system component.
    // The returned handles can be used later to take away anything that was granted.
    void GiveToAbilitySystem(ULyraAbilitySystemComponent* LyraASC, FLyraAbilitySet_GrantedHandles* OutGrantedHandles, UObject* SourceObject = nullptr) const;

protected:

    // Gameplay abilities to grant when this ability set is granted.
    UPROPERTY(EditDefaultsOnly, Category = "Gameplay Abilities", meta=(TitleProperty=Ability))
    TArray<FLyraAbilitySet_GameplayAbility> GrantedGameplayAbilities;

    // Gameplay effects to grant when this ability set is granted.
    UPROPERTY(EditDefaultsOnly, Category = "Gameplay Effects", meta=(TitleProperty=GameplayEffect))
    TArray<FLyraAbilitySet_GameplayEffect> GrantedGameplayEffects;

    // Attribute sets to grant when this ability set is granted.
    UPROPERTY(EditDefaultsOnly, Category = "Attribute Sets", meta=(TitleProperty=AttributeSet))
    TArray<FLyraAbilitySet_AttributeSet> GrantedAttributes;
};
```

具体的涉及的结构体的定义，随便看看就行：

```c++
/**
 * FLyraAbilitySet_GameplayAbility
 *
 *  Data used by the ability set to grant gameplay abilities.
 */
USTRUCT(BlueprintType)
struct FLyraAbilitySet_GameplayAbility
{
    GENERATED_BODY()

public:

    // Gameplay ability to grant.
    UPROPERTY(EditDefaultsOnly)
    TSubclassOf<ULyraGameplayAbility> Ability = nullptr;

    // Level of ability to grant.
    UPROPERTY(EditDefaultsOnly)
    int32 AbilityLevel = 1;

    // Tag used to process input for the ability.
    UPROPERTY(EditDefaultsOnly, Meta = (Categories = "InputTag"))
    FGameplayTag InputTag;
};


/**
 * FLyraAbilitySet_GameplayEffect
 *
 *  Data used by the ability set to grant gameplay effects.
 */
USTRUCT(BlueprintType)
struct FLyraAbilitySet_GameplayEffect
{
    GENERATED_BODY()

public:

    // Gameplay effect to grant.
    UPROPERTY(EditDefaultsOnly)
    TSubclassOf<UGameplayEffect> GameplayEffect = nullptr;

    // Level of gameplay effect to grant.
    UPROPERTY(EditDefaultsOnly)
    float EffectLevel = 1.0f;
};

/**
 * FLyraAbilitySet_AttributeSet
 *
 *  Data used by the ability set to grant attribute sets.
 */
USTRUCT(BlueprintType)
struct FLyraAbilitySet_AttributeSet
{
    GENERATED_BODY()

public:
    // Gameplay effect to grant.
    UPROPERTY(EditDefaultsOnly)
    TSubclassOf<UAttributeSet> AttributeSet;

};

/**
 * FLyraAbilitySet_GrantedHandles
 *
 *  Data used to store handles to what has been granted by the ability set.
 */
USTRUCT(BlueprintType)
struct FLyraAbilitySet_GrantedHandles
{
    GENERATED_BODY()

public:

    void AddAbilitySpecHandle(const FGameplayAbilitySpecHandle& Handle);
    void AddGameplayEffectHandle(const FActiveGameplayEffectHandle& Handle);
    void AddAttributeSet(UAttributeSet* Set);

    void TakeFromAbilitySystem(ULyraAbilitySystemComponent* LyraASC);

protected:

    // Handles to the granted abilities.
    UPROPERTY()
    TArray<FGameplayAbilitySpecHandle> AbilitySpecHandles;

    // Handles to the granted gameplay effects.
    UPROPERTY()
    TArray<FActiveGameplayEffectHandle> GameplayEffectHandles;

    // Pointers to the granted attribute sets
    UPROPERTY()
    TArray<TObjectPtr<UAttributeSet>> GrantedAttributeSets;
};
```

###### AbilitySet的GiveToAbilitySystem的实现：

​	本质上就是把AbilitySet中打包好的信息拿出来，按照上面的信息去把GAS相关的东西给到目标的ASC，例如对于装备来说，就给一些Ability，让Player的ASC获得这些ASC然后可以去用。

```c++
void ULyraAbilitySet::GiveToAbilitySystem(ULyraAbilitySystemComponent* LyraASC, FLyraAbilitySet_GrantedHandles* OutGrantedHandles, UObject* SourceObject) const
{
    check(LyraASC);

    if (!LyraASC->IsOwnerActorAuthoritative())
    {
       // Must be authoritative to give or take ability sets.
       return;
    }
    
    // Grant the attribute sets.
    for (int32 SetIndex = 0; SetIndex < GrantedAttributes.Num(); ++SetIndex)
    {
       const FLyraAbilitySet_AttributeSet& SetToGrant = GrantedAttributes[SetIndex];

       if (!IsValid(SetToGrant.AttributeSet))
       {
          UE_LOG(LogLyraAbilitySystem, Error, TEXT("GrantedAttributes[%d] on ability set [%s] is not valid"), SetIndex, *GetNameSafe(this));
          continue;
       }

       UAttributeSet* NewSet = NewObject<UAttributeSet>(LyraASC->GetOwner(), SetToGrant.AttributeSet);
       LyraASC->AddAttributeSetSubobject(NewSet);

       if (OutGrantedHandles)
       {
          OutGrantedHandles->AddAttributeSet(NewSet);
       }
    }

    // Grant the gameplay abilities.
    for (int32 AbilityIndex = 0; AbilityIndex < GrantedGameplayAbilities.Num(); ++AbilityIndex)
    {
       const FLyraAbilitySet_GameplayAbility& AbilityToGrant = GrantedGameplayAbilities[AbilityIndex];

       if (!IsValid(AbilityToGrant.Ability))
       {
          UE_LOG(LogLyraAbilitySystem, Error, TEXT("GrantedGameplayAbilities[%d] on ability set [%s] is not valid."), AbilityIndex, *GetNameSafe(this));
          continue;
       }

       ULyraGameplayAbility* AbilityCDO = AbilityToGrant.Ability->GetDefaultObject<ULyraGameplayAbility>();

       FGameplayAbilitySpec AbilitySpec(AbilityCDO, AbilityToGrant.AbilityLevel);
       AbilitySpec.SourceObject = SourceObject;
       AbilitySpec.GetDynamicSpecSourceTags().AddTag(AbilityToGrant.InputTag);

       const FGameplayAbilitySpecHandle AbilitySpecHandle = LyraASC->GiveAbility(AbilitySpec);

       if (OutGrantedHandles)
       {
          OutGrantedHandles->AddAbilitySpecHandle(AbilitySpecHandle);
       }
    }

    // Grant the gameplay effects.
    for (int32 EffectIndex = 0; EffectIndex < GrantedGameplayEffects.Num(); ++EffectIndex)
    {
       const FLyraAbilitySet_GameplayEffect& EffectToGrant = GrantedGameplayEffects[EffectIndex];

       if (!IsValid(EffectToGrant.GameplayEffect))
       {
          UE_LOG(LogLyraAbilitySystem, Error, TEXT("GrantedGameplayEffects[%d] on ability set [%s] is not valid"), EffectIndex, *GetNameSafe(this));
          continue;
       }

       const UGameplayEffect* GameplayEffect = EffectToGrant.GameplayEffect->GetDefaultObject<UGameplayEffect>();
       const FActiveGameplayEffectHandle GameplayEffectHandle = LyraASC->ApplyGameplayEffectToSelf(GameplayEffect, EffectToGrant.EffectLevel, LyraASC->MakeEffectContext());

       if (OutGrantedHandles)
       {
          OutGrantedHandles->AddGameplayEffectHandle(GameplayEffectHandle);
       }
    }
}
```



##### RemoveEntry的实现

```
void FLyraEquipmentList::RemoveEntry(ULyraEquipmentInstance* Instance)
{
    for (auto EntryIt = Entries.CreateIterator(); EntryIt; ++EntryIt)
    {
       FLyraAppliedEquipmentEntry& Entry = *EntryIt;
       if (Entry.Instance == Instance)
       {
          if (ULyraAbilitySystemComponent* ASC = GetAbilitySystemComponent())
          {
             Entry.GrantedHandles.TakeFromAbilitySystem(ASC);
          }

          Instance->DestroyEquipmentActors();
          

          EntryIt.RemoveCurrent();
          MarkArrayDirty();
       }
    }
}
```



#### 2.1.2 EquipmentList

```c++
/** List of applied equipment */
USTRUCT(BlueprintType)
struct FLyraEquipmentList : public FFastArraySerializer
{
    GENERATED_BODY()

    FLyraEquipmentList()
       : OwnerComponent(nullptr)
    {
    }

    FLyraEquipmentList(UActorComponent* InOwnerComponent)
       : OwnerComponent(InOwnerComponent)
    {
    }

public:
    //~FFastArraySerializer contract
    void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
    void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
    void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
    //~End of FFastArraySerializer contract

    bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
    {
       return FFastArraySerializer::FastArrayDeltaSerialize<FLyraAppliedEquipmentEntry, FLyraEquipmentList>(Entries, DeltaParms, *this);
    }

    ULyraEquipmentInstance* AddEntry(TSubclassOf<ULyraEquipmentDefinition> EquipmentDefinition);
    void RemoveEntry(ULyraEquipmentInstance* Instance);

private:
    ULyraAbilitySystemComponent* GetAbilitySystemComponent() const;

    friend ULyraEquipmentManagerComponent;

private:
    // Replicated list of equipment entries
    UPROPERTY()
    TArray<FLyraAppliedEquipmentEntry> Entries;

    UPROPERTY(NotReplicated)
    TObjectPtr<UActorComponent> OwnerComponent;
};
```

​	EquipmentList和InventoryList十分相似，也是维护了一个Entry的TArray和一个OwnerComponent，AddEntry和RemoveEntry的思路和InventoryList都是差不多的，注意到List里面特别的还有一个GetAbilitySystemComponent的函数，可知Equipment涉及到了GAS的东西。

#### 2.1.3 EquipmentManagerComponent

.h

```c++
/**
 * Manages equipment applied to a pawn
 */
UCLASS(BlueprintType, Const)
class LYRAGAME_API ULyraEquipmentManagerComponent : public UPawnComponent
{
    GENERATED_BODY()

public:
    ULyraEquipmentManagerComponent(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

    UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly)
    ULyraEquipmentInstance* EquipItem(TSubclassOf<ULyraEquipmentDefinition> EquipmentDefinition);

    UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly)
    void UnequipItem(ULyraEquipmentInstance* ItemInstance);

    //~UObject interface
    virtual bool ReplicateSubobjects(class UActorChannel* Channel, class FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
    //~End of UObject interface

    //~UActorComponent interface
    //virtual void EndPlay() override;
    virtual void InitializeComponent() override;
    virtual void UninitializeComponent() override;
    virtual void ReadyForReplication() override;
    //~End of UActorComponent interface

    /** Returns the first equipped instance of a given type, or nullptr if none are found */
    UFUNCTION(BlueprintCallable, BlueprintPure)
    ULyraEquipmentInstance* GetFirstInstanceOfType(TSubclassOf<ULyraEquipmentInstance> InstanceType);

    /** Returns all equipped instances of a given type, or an empty array if none are found */
    UFUNCTION(BlueprintCallable, BlueprintPure)
    TArray<ULyraEquipmentInstance*> GetEquipmentInstancesOfType(TSubclassOf<ULyraEquipmentInstance> InstanceType) const;

    template <typename T>
    T* GetFirstInstanceOfType()
    {
       return (T*)GetFirstInstanceOfType(T::StaticClass());
    }

private:
    UPROPERTY(Replicated)
    FLyraEquipmentList EquipmentList;
};
```

##### EquipItem和UnequipItem

​	本质上就是去调用EquipmentList的AddEntry和RemoveEntry，并且去触发EquipmentInstance的OnEquipped或OnUnequipped

```c++
ULyraEquipmentInstance* ULyraEquipmentManagerComponent::EquipItem(TSubclassOf<ULyraEquipmentDefinition> EquipmentClass)
{
    ULyraEquipmentInstance* Result = nullptr;
    if (EquipmentClass != nullptr)
    {
       Result = EquipmentList.AddEntry(EquipmentClass);
       if (Result != nullptr)
       {
          Result->OnEquipped();

          if (IsUsingRegisteredSubObjectList() && IsReadyForReplication())
          {
             AddReplicatedSubObject(Result);
          }
       }
    }
    return Result;
}

void ULyraEquipmentManagerComponent::UnequipItem(ULyraEquipmentInstance* ItemInstance)
{
    if (ItemInstance != nullptr)
    {
       if (IsUsingRegisteredSubObjectList())
       {
          RemoveReplicatedSubObject(ItemInstance);
       }

       ItemInstance->OnUnequipped();
       EquipmentList.RemoveEntry(ItemInstance);
    }
}
```

​	EquipmentManagerComponent的内容就大概如此，EquipmentManagerComponent只是负责了Equipment的装卸的控制，最重要的功能就是把Equipment带有的Abilities授予给装备者，但是如何使用这些Abilities并非EquipmentManagerComponent的控制范围。由于Lyra中没有“防具”“饰品”之类的其他类型的Equipment，只有Weapon这种Equipment，而Weapon的功能的发挥肯定是要靠玩家输入的，比如像射击、换弹等等，而要使用一把Weapon，肯定要去”选用“它，而这件事情的实现就在LyraQuickBarComponent中，而QuickBar的Slot选取是通过GameplayAbility来实现的。同时，实际上是由QuickBarComponent来决定了装备什么武器，也就是EquipmentManagerComponent是服务于QuickBarComponent选择了哪个槽位中的Weapon的。

​	接下来我们就来看看LyraQuickBarComponent的内容。

## 3. LyraQuickBarComponent

### 3.1 QuickBarComponent

.h

```c++
#include "Components/ControllerComponent.h"
#include "Inventory/LyraInventoryItemInstance.h"

#include "LyraQuickBarComponent.generated.h"

class AActor;
class ULyraEquipmentInstance;
class ULyraEquipmentManagerComponent;
class UObject;
struct FFrame;

UCLASS(Blueprintable, meta=(BlueprintSpawnableComponent))
class ULyraQuickBarComponent : public UControllerComponent
{
    GENERATED_BODY()

public:
    ULyraQuickBarComponent(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

    UFUNCTION(BlueprintCallable, Category="Lyra")
    void CycleActiveSlotForward();

    UFUNCTION(BlueprintCallable, Category="Lyra")
    void CycleActiveSlotBackward();

    UFUNCTION(Server, Reliable, BlueprintCallable, Category="Lyra")
    void SetActiveSlotIndex(int32 NewIndex);

    UFUNCTION(BlueprintCallable, BlueprintPure=false)
    TArray<ULyraInventoryItemInstance*> GetSlots() const
    {
       return Slots;
    }

    UFUNCTION(BlueprintCallable, BlueprintPure=false)
    int32 GetActiveSlotIndex() const { return ActiveSlotIndex; }

    UFUNCTION(BlueprintCallable, BlueprintPure = false)
    ULyraInventoryItemInstance* GetActiveSlotItem() const;

    UFUNCTION(BlueprintCallable, BlueprintPure=false)
    int32 GetNextFreeItemSlot() const;

    UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly)
    void AddItemToSlot(int32 SlotIndex, ULyraInventoryItemInstance* Item);

    UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly)
    ULyraInventoryItemInstance* RemoveItemFromSlot(int32 SlotIndex);

    virtual void BeginPlay() override;

private:
    void UnequipItemInSlot();
    void EquipItemInSlot();

    ULyraEquipmentManagerComponent* FindEquipmentManager() const;

protected:
    UPROPERTY()
    int32 NumSlots = 3;

    UFUNCTION()
    void OnRep_Slots();

    UFUNCTION()
    void OnRep_ActiveSlotIndex();

private:
    UPROPERTY(ReplicatedUsing=OnRep_Slots)
    TArray<TObjectPtr<ULyraInventoryItemInstance>> Slots;

    UPROPERTY(ReplicatedUsing=OnRep_ActiveSlotIndex)
    int32 ActiveSlotIndex = -1;

    UPROPERTY()
    TObjectPtr<ULyraEquipmentInstance> EquippedItem;
};
```

​	QuickBarComponent主要维护了几个东西：

- 一个TArray<TObjectPtr<ULyraInventoryItemInstance>> Slots;
- 一个int32 NumSlots = 3;
- 一个int32 ActiveSlotIndex = -1;
- 一个TObjectPtr<ULyraEquipmentInstance> EquippedItem;

​	Slots管理了存在于QuickBar中的ItemInstance，注意是**ItemInstance**。

​	NumSlots写死了QuickBar的容量，决定了Slots实际上能存有多少个ItemInstance

​	ActiveSlotIndex表示了正在激活的Slot的编号，-1代表无激活。

​	EquippedItem是一个对当前装备着的Item的引用。

.cpp

```c++
void ULyraQuickBarComponent::CycleActiveSlotForward()
{
    if (Slots.Num() < 2)
    {
       return;
    }

    const int32 OldIndex = (ActiveSlotIndex < 0 ? Slots.Num()-1 : ActiveSlotIndex);
    int32 NewIndex = ActiveSlotIndex;
    do
    {
       NewIndex = (NewIndex + 1) % Slots.Num();
       if (Slots[NewIndex] != nullptr)
       {
          SetActiveSlotIndex(NewIndex);
          return;
       }
    } while (NewIndex != OldIndex);
}

void ULyraQuickBarComponent::CycleActiveSlotBackward()
{
    if (Slots.Num() < 2)
    {
       return;
    }

    const int32 OldIndex = (ActiveSlotIndex < 0 ? Slots.Num()-1 : ActiveSlotIndex);
    int32 NewIndex = ActiveSlotIndex;
    do
    {
       NewIndex = (NewIndex - 1 + Slots.Num()) % Slots.Num();
       if (Slots[NewIndex] != nullptr)
       {
          SetActiveSlotIndex(NewIndex);
          return;
       }
    } while (NewIndex != OldIndex);
}

void ULyraQuickBarComponent::EquipItemInSlot()
{
    check(Slots.IsValidIndex(ActiveSlotIndex));
    check(EquippedItem == nullptr);

    if (ULyraInventoryItemInstance* SlotItem = Slots[ActiveSlotIndex])
    {
       if (const UInventoryFragment_EquippableItem* EquipInfo = SlotItem->FindFragmentByClass<UInventoryFragment_EquippableItem>())
       {
          TSubclassOf<ULyraEquipmentDefinition> EquipDef = EquipInfo->EquipmentDefinition;
          if (EquipDef != nullptr)
          {
             if (ULyraEquipmentManagerComponent* EquipmentManager = FindEquipmentManager())
             {
                EquippedItem = EquipmentManager->EquipItem(EquipDef);
                if (EquippedItem != nullptr)
                {
                   EquippedItem->SetInstigator(SlotItem);
                }
             }
          }
       }
    }
}

void ULyraQuickBarComponent::UnequipItemInSlot()
{
    if (ULyraEquipmentManagerComponent* EquipmentManager = FindEquipmentManager())
    {
       if (EquippedItem != nullptr)
       {
          EquipmentManager->UnequipItem(EquippedItem);
          EquippedItem = nullptr;
       }
    }
}

ULyraEquipmentManagerComponent* ULyraQuickBarComponent::FindEquipmentManager() const
{
    if (AController* OwnerController = Cast<AController>(GetOwner()))
    {
       if (APawn* Pawn = OwnerController->GetPawn())
       {
          return Pawn->FindComponentByClass<ULyraEquipmentManagerComponent>();
       }
    }
    return nullptr;
}

void ULyraQuickBarComponent::SetActiveSlotIndex_Implementation(int32 NewIndex)
{
    if (Slots.IsValidIndex(NewIndex) && (ActiveSlotIndex != NewIndex))
    {
       UnequipItemInSlot();

       ActiveSlotIndex = NewIndex;

       EquipItemInSlot();

       OnRep_ActiveSlotIndex();
    }
}

ULyraInventoryItemInstance* ULyraQuickBarComponent::GetActiveSlotItem() const
{
    return Slots.IsValidIndex(ActiveSlotIndex) ? Slots[ActiveSlotIndex] : nullptr;
}

int32 ULyraQuickBarComponent::GetNextFreeItemSlot() const
{
    int32 SlotIndex = 0;
    for (const TObjectPtr<ULyraInventoryItemInstance>& ItemPtr : Slots)
    {
       if (ItemPtr == nullptr)
       {
          return SlotIndex;
       }
       ++SlotIndex;
    }

    return INDEX_NONE;
}

void ULyraQuickBarComponent::AddItemToSlot(int32 SlotIndex, ULyraInventoryItemInstance* Item)
{
    if (Slots.IsValidIndex(SlotIndex) && (Item != nullptr))
    {
       if (Slots[SlotIndex] == nullptr)
       {
          Slots[SlotIndex] = Item;
          OnRep_Slots();
       }
    }
}

ULyraInventoryItemInstance* ULyraQuickBarComponent::RemoveItemFromSlot(int32 SlotIndex)
{
    ULyraInventoryItemInstance* Result = nullptr;

    if (ActiveSlotIndex == SlotIndex)
    {
       UnequipItemInSlot();
       ActiveSlotIndex = -1;
    }

    if (Slots.IsValidIndex(SlotIndex))
    {
       Result = Slots[SlotIndex];

       if (Result != nullptr)
       {
          Slots[SlotIndex] = nullptr;
          OnRep_Slots();
       }
    }

    return Result;
}

void ULyraQuickBarComponent::OnRep_Slots()
{
    FLyraQuickBarSlotsChangedMessage Message;
    Message.Owner = GetOwner();
    Message.Slots = Slots;

    UGameplayMessageSubsystem& MessageSystem = UGameplayMessageSubsystem::Get(this);
    MessageSystem.BroadcastMessage(TAG_Lyra_QuickBar_Message_SlotsChanged, Message);
}

void ULyraQuickBarComponent::OnRep_ActiveSlotIndex()
{
    FLyraQuickBarActiveIndexChangedMessage Message;
    Message.Owner = GetOwner();
    Message.ActiveIndex = ActiveSlotIndex;

    UGameplayMessageSubsystem& MessageSystem = UGameplayMessageSubsystem::Get(this);
    MessageSystem.BroadcastMessage(TAG_Lyra_QuickBar_Message_ActiveIndexChanged, Message);
}
```

​	主要关注和**选择**”Slot“相关的函数，其大致思路就是去选择QuickBar的Slot，被选取的Slot就通过函数SetActiveSlotIndex更新为ActiveSlot。在调用SetActiveSlotIndex函数时还会去装备上当前选中的QuickBarSlot中的Item，当然前置的一个逻辑就是先把之前装备的Item给卸载掉，这就又涉及到前面EquipmentManagerComponent中的装卸Equipment的逻辑了。

​	BTW通过ULyraQuickBarComponent::FindEquipmentManager()可以看出EquipmentManagerComponent是挂在**Pawn**上而QuickBarComponent都是挂载在**Controller**上的，还可以观察到Lyra中普遍的获取一个Actor上的Component的方式，即直接通过遍历Actor上的OwnedComponents去暴力找出对应Class的Component，而不是通过接口之类的或者是定义一个成员变量初始化之后一直拿着对应Component的引用可以去用。（这是不是不太好？）

​	此外还可以看到，这里使用了FindComponentByClass而不是GetComponentByClass，是因为FindComponentByClass返回的就是Find的Class而不是返回一个UActorComponent指针，这样就不需要再多一步Cast<>()。

![image-20250129170028488](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250129170028488.png)

#### 3.1.1 QuickBarSlot 的选择

​	QuickBarSlot 的选择的具体逻辑在QuickBarComponent中实现了，但是其触发的地方值得研究。

​	首先，Lyra使用了一个GameplayAbility——GA_QucikBarSlots来实现对QuickBar输入的接收，这是一个没有EndAbility的GA，也就说明它是一个被动“技能”，它的作用就是**永久性地监听**GameplayEvent，来实现QuickBar的选择的改变

![image-20250213165147768](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250213165147768.png)

​	当接收到GameplayEvent时，它就会调用QuickBarComponent中对应的逻辑。

![image-20250213165259665](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250213165259665.png)	而GameplayEvent的发送是由Character直接完成的，它绑定了QuickBar相关的IA，实现了发送GameplayEvent

![image-20250213165422437](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250213165422437.png)

​	Lyra的Character中，无论是用数字键指定地设置选中的Slot还是用鼠标滚轮，都共用了同一个内部的函数ChangeQuickBarSlot，即使鼠标滚轮的选取不需要输入NewSlotIndex，这样的程序设计是不错的。

![image-20250213165758144](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250213165758144.png)







​	

​	Lyra的Inventory相关的内容就大概如此。

## PART II GameplayAbilitySystem

​	首先来看Lyra的AttributeSet基类。Lyra的AttributeSet基类LyraAttributeSet设计得很有意思，首先Lyra用一个基本算没什么东西的基类，先把创建Attribute的帮助宏给引入了，然后派生的有实际意义的AttributeSet引入了基类的头文件，就相当于引入了帮助宏，而且LyraAttributeSet还定义了一个**多播委托FLyraAttributeEvent**，用于管理Attribute相关的事件广播。

### 1. AttributeSet

#### 1.1 LyraAttributeSet——Lyra中的AttributeSet的基类

```c++
#include "AttributeSet.h"

#include "LyraAttributeSet.generated.h"

class AActor;
class ULyraAbilitySystemComponent;
class UObject;
class UWorld;
struct FGameplayEffectSpec;


/**
 * This macro defines a set of helper functions for accessing and initializing attributes.
 *
 * The following example of the macro:
 *     ATTRIBUTE_ACCESSORS(ULyraHealthSet, Health)
 * will create the following functions:
 *     static FGameplayAttribute GetHealthAttribute();
 *     float GetHealth() const;
 *     void SetHealth(float NewVal);
 *     void InitHealth(float NewVal);
 */
#define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \
    GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \
    GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \
    GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \
    GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)

/** 
 * Delegate used to broadcast attribute events, some of these parameters may be null on clients: 
 * @param EffectInstigator  The original instigating actor for this event
 * @param EffectCauser     The physical actor that caused the change
 * @param EffectSpec       The full effect spec for this change
 * @param EffectMagnitude   The raw magnitude, this is before clamping
 * @param OldValue        The value of the attribute before it was changed
 * @param NewValue        The value after it was changed
*/
DECLARE_MULTICAST_DELEGATE_SixParams(FLyraAttributeEvent, AActor* /*EffectInstigator*/, AActor* /*EffectCauser*/, const FGameplayEffectSpec* /*EffectSpec*/, float /*EffectMagnitude*/, float /*OldValue*/, float /*NewValue*/);

/**
 * ULyraAttributeSet
 *
 *  Base attribute set class for the project.
 */
UCLASS()
class LYRAGAME_API ULyraAttributeSet : public UAttributeSet
{
    GENERATED_BODY()

public:

    ULyraAttributeSet();

    UWorld* GetWorld() const override;

    ULyraAbilitySystemComponent* GetLyraAbilitySystemComponent() const;
};
```

#### 1.2 HeathSet

​	Lyra专门设置了一个HealthSet来管理Lyra的生命值，其中使用到了MetaAttribute的概念，即Healing和Damage

​	接下再来看HealthSet。

​	首先一上来使用了一些Lyra中定义的声明NativeTag的宏来声明一些相关的GameplayTag，暂时可以不用管。

​	接着是很常规的使用帮助宏创建其他东西。

​	接着是声明几个了LyraAttributeSet中定义的委托类型的委托实例用来广播Attribute变化（这里就只是关于Health），以及Health为0的情况。

> [!NOTE]
>
> ​	这里委托变量前面的关键字**mutable**是和关键字const相反作用的，它可以使得修饰的变量能够突破const函数限制修改类成员的限制，被mutable关键字修饰过的变量即使出现在类的const函数中也允许被修改。



```c++
#include "AbilitySystemComponent.h"
#include "LyraAttributeSet.h"
#include "NativeGameplayTags.h"

#include "LyraHealthSet.generated.h"

class UObject;
struct FFrame;

LYRAGAME_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Gameplay_Damage);
LYRAGAME_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Gameplay_DamageImmunity);
LYRAGAME_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Gameplay_DamageSelfDestruct);
LYRAGAME_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Gameplay_FellOutOfWorld);
LYRAGAME_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Lyra_Damage_Message);

struct FGameplayEffectModCallbackData;


/**
 * ULyraHealthSet
 *
 *  Class that defines attributes that are necessary for taking damage.
 *  Attribute examples include: health, shields, and resistances.
 */
UCLASS(BlueprintType)
class LYRAGAME_API ULyraHealthSet : public ULyraAttributeSet
{
    GENERATED_BODY()

public:

    ULyraHealthSet();

    ATTRIBUTE_ACCESSORS(ULyraHealthSet, Health);
    ATTRIBUTE_ACCESSORS(ULyraHealthSet, MaxHealth);
    ATTRIBUTE_ACCESSORS(ULyraHealthSet, Healing);
    ATTRIBUTE_ACCESSORS(ULyraHealthSet, Damage);

    // Delegate when health changes due to damage/healing, some information may be missing on the client
    mutable FLyraAttributeEvent OnHealthChanged;

    // Delegate when max health changes
    mutable FLyraAttributeEvent OnMaxHealthChanged;

    // Delegate to broadcast when the health attribute reaches zero
    mutable FLyraAttributeEvent OnOutOfHealth;

protected:

    UFUNCTION()
    void OnRep_Health(const FGameplayAttributeData& OldValue);

    UFUNCTION()
    void OnRep_MaxHealth(const FGameplayAttributeData& OldValue);

    virtual bool PreGameplayEffectExecute(FGameplayEffectModCallbackData& Data) override;
    virtual void PostGameplayEffectExecute(const FGameplayEffectModCallbackData& Data) override;

    virtual void PreAttributeBaseChange(const FGameplayAttribute& Attribute, float& NewValue) const override;
    virtual void PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue) override;
    virtual void PostAttributeChange(const FGameplayAttribute& Attribute, float OldValue, float NewValue) override;

    void ClampAttribute(const FGameplayAttribute& Attribute, float& NewValue) const;

private:

    // The current health attribute.  The health will be capped by the max health attribute.  Health is hidden from modifiers so only executions can modify it.
    UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Health, Category = "Lyra|Health", Meta = (HideFromModifiers, AllowPrivateAccess = true))
    FGameplayAttributeData Health;

    // The current max health attribute.  Max health is an attribute since gameplay effects can modify it.
    UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxHealth, Category = "Lyra|Health", Meta = (AllowPrivateAccess = true))
    FGameplayAttributeData MaxHealth;

    // Used to track when the health reaches 0.
    bool bOutOfHealth;

    // Store the health before any changes 
    float MaxHealthBeforeAttributeChange;
    float HealthBeforeAttributeChange;

    // -------------------------------------------------------------------
    // Meta Attribute (please keep attributes that aren't 'stateful' below 
    // -------------------------------------------------------------------

    // Incoming healing. This is mapped directly to +Health
    UPROPERTY(BlueprintReadOnly, Category="Lyra|Health", Meta=(AllowPrivateAccess=true))
    FGameplayAttributeData Healing;

    // Incoming damage. This is mapped directly to -Health
    UPROPERTY(BlueprintReadOnly, Category="Lyra|Health", Meta=(HideFromModifiers, AllowPrivateAccess=true))
    FGameplayAttributeData Damage;
};
```

​	接着来看.cpp中各种函数，首先先来看Pre/PostGameplayEffectExcute：

##### PreGameplayEffectExcute

```c++
bool ULyraHealthSet::PreGameplayEffectExecute(FGameplayEffectModCallbackData &Data)
{
    if (!Super::PreGameplayEffectExecute(Data))
    {
       return false;
    }

    // Handle modifying incoming normal damage
    if (Data.EvaluatedData.Attribute == GetDamageAttribute())
    {
       if (Data.EvaluatedData.Magnitude > 0.0f)
       {
          const bool bIsDamageFromSelfDestruct = Data.EffectSpec.GetDynamicAssetTags().HasTagExact(TAG_Gameplay_DamageSelfDestruct);

          if (Data.Target.HasMatchingGameplayTag(TAG_Gameplay_DamageImmunity) && !bIsDamageFromSelfDestruct)
          {
             // Do not take away any health.
             Data.EvaluatedData.Magnitude = 0.0f;
             return false;
          }

#if !UE_BUILD_SHIPPING
          // Check GodMode cheat, unlimited health is checked below
          if (Data.Target.HasMatchingGameplayTag(LyraGameplayTags::Cheat_GodMode) && !bIsDamageFromSelfDestruct)
          {
             // Do not take away any health.
             Data.EvaluatedData.Magnitude = 0.0f;
             return false;
          }
#endif // #if !UE_BUILD_SHIPPING
       }
    }

    // Save the current health
    HealthBeforeAttributeChange = GetHealth();
    MaxHealthBeforeAttributeChange = GetMaxHealth();

    return true;
}
```

​	PreGameplayEffect中比较重要的是对伤害条件进行了一些判断，以及存储了一下在GE生效前的Health和MaxHealth（Attribute）的值，以便后面PostGameplayEffectExcute中判断是否要广播HealthChange的时候要用到，这点很重要。

##### PostGameplayEffectExcute

```c++
void ULyraHealthSet::PostGameplayEffectExecute(const FGameplayEffectModCallbackData& Data)
{
    Super::PostGameplayEffectExecute(Data);

    const bool bIsDamageFromSelfDestruct = Data.EffectSpec.GetDynamicAssetTags().HasTagExact(TAG_Gameplay_DamageSelfDestruct);
    float MinimumHealth = 0.0f;

#if !UE_BUILD_SHIPPING
    // Godmode and unlimited health stop death unless it's a self destruct
    if (!bIsDamageFromSelfDestruct &&
       (Data.Target.HasMatchingGameplayTag(LyraGameplayTags::Cheat_GodMode) || Data.Target.HasMatchingGameplayTag(LyraGameplayTags::Cheat_UnlimitedHealth) ))
    {
       MinimumHealth = 1.0f;
    }
#endif // #if !UE_BUILD_SHIPPING

    const FGameplayEffectContextHandle& EffectContext = Data.EffectSpec.GetEffectContext();
    AActor* Instigator = EffectContext.GetOriginalInstigator();
    AActor* Causer = EffectContext.GetEffectCauser();

    if (Data.EvaluatedData.Attribute == GetDamageAttribute())
    {
       // Send a standardized verb message that other systems can observe
       if (Data.EvaluatedData.Magnitude > 0.0f)
       {
          FLyraVerbMessage Message;
          Message.Verb = TAG_Lyra_Damage_Message;
          Message.Instigator = Data.EffectSpec.GetEffectContext().GetEffectCauser();
          Message.InstigatorTags = *Data.EffectSpec.CapturedSourceTags.GetAggregatedTags();
          Message.Target = GetOwningActor();
          Message.TargetTags = *Data.EffectSpec.CapturedTargetTags.GetAggregatedTags();
          //@TODO: Fill out context tags, and any non-ability-system source/instigator tags
          //@TODO: Determine if it's an opposing team kill, self-own, team kill, etc...
          Message.Magnitude = Data.EvaluatedData.Magnitude;

          UGameplayMessageSubsystem& MessageSystem = UGameplayMessageSubsystem::Get(GetWorld());
          MessageSystem.BroadcastMessage(Message.Verb, Message);
       }

       // Convert into -Health and then clamp
       SetHealth(FMath::Clamp(GetHealth() - GetDamage(), MinimumHealth, GetMaxHealth()));
       SetDamage(0.0f);
    }
    else if (Data.EvaluatedData.Attribute == GetHealingAttribute())
    {
       // Convert into +Health and then clamp
       SetHealth(FMath::Clamp(GetHealth() + GetHealing(), MinimumHealth, GetMaxHealth()));
       SetHealing(0.0f);
    }
    else if (Data.EvaluatedData.Attribute == GetHealthAttribute())
    {
       // Clamp and fall into out of health handling below
       SetHealth(FMath::Clamp(GetHealth(), MinimumHealth, GetMaxHealth()));
    }
    else if (Data.EvaluatedData.Attribute == GetMaxHealthAttribute())
    {
       // TODO clamp current health?

       // Notify on any requested max health changes
       OnMaxHealthChanged.Broadcast(Instigator, Causer, &Data.EffectSpec, Data.EvaluatedData.Magnitude, MaxHealthBeforeAttributeChange, GetMaxHealth());
    }

    // If health has actually changed activate callbacks
    if (GetHealth() != HealthBeforeAttributeChange)
    {
       OnHealthChanged.Broadcast(Instigator, Causer, &Data.EffectSpec, Data.EvaluatedData.Magnitude, HealthBeforeAttributeChange, GetHealth());
    }

    if ((GetHealth() <= 0.0f) && !bOutOfHealth)
    {
       OnOutOfHealth.Broadcast(Instigator, Causer, &Data.EffectSpec, Data.EvaluatedData.Magnitude, HealthBeforeAttributeChange, GetHealth());
    }

    // Check health again in case an event above changed it.
    bOutOfHealth = (GetHealth() <= 0.0f);
}
```

​	PostGameplayEffectExecute中首先比较常规的是进行了夹值保证Attribute（就是Health）不会超出不合理的范围。由于HealthSet用到了MetaAttribute来作为中间值，所以实际上Health的改变量是由Damage和Healing在夹值Clamp中去实际进行的，每次用完Healing和Damage去修改Health之后就会把它们Reset成0，这一点注释很简单地指出来了。

​	PostGameplayEffect中很聪明的一点在于通过比较GameplayEffect应用前后的Health是否相等（通过缓存的HealthBeforeAttributeChange和GetHealth()进行比较），来决定是否要广播Health的改变，这就和通过FOnGameplayAttributeValueChange只要Attribute受到改变就会进行广播的广播方式有点不同。

​	

​	剩下几个函数随便看看即可，问题不大，主要是进行一些夹值避免出bug。

```c++
void ULyraHealthSet::PreAttributeBaseChange(const FGameplayAttribute& Attribute, float& NewValue) const
{
    Super::PreAttributeBaseChange(Attribute, NewValue);

    ClampAttribute(Attribute, NewValue);
}

void ULyraHealthSet::PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue)
{
    Super::PreAttributeChange(Attribute, NewValue);

    ClampAttribute(Attribute, NewValue);
}

void ULyraHealthSet::PostAttributeChange(const FGameplayAttribute& Attribute, float OldValue, float NewValue)
{
    Super::PostAttributeChange(Attribute, OldValue, NewValue);

    if (Attribute == GetMaxHealthAttribute())
    {
       // Make sure current health is not greater than the new max health.
       if (GetHealth() > NewValue)
       {
          ULyraAbilitySystemComponent* LyraASC = GetLyraAbilitySystemComponent();
          check(LyraASC);

          LyraASC->ApplyModToAttribute(GetHealthAttribute(), EGameplayModOp::Override, NewValue);
       }
    }

    if (bOutOfHealth && (GetHealth() > 0.0f))
    {
       bOutOfHealth = false;
    }
}

void ULyraHealthSet::ClampAttribute(const FGameplayAttribute& Attribute, float& NewValue) const
{
    if (Attribute == GetHealthAttribute())
    {
       // Do not allow health to go negative or above max health.
       NewValue = FMath::Clamp(NewValue, 0.0f, GetMaxHealth());
    }
    else if (Attribute == GetMaxHealthAttribute())
    {
       // Do not allow max health to drop below 1.
       NewValue = FMath::Max(NewValue, 1.0f);
    }
}
```

​	Lyra的HealthSet基本上就是用于管理Lyra的生命值机制的逻辑，我们检查OnHealthChanged的用法，可以发现它在**LyraHealthComponent**中进行了回调函数的绑定，而这个组件就专门用来处理Lyra中Character的Health的变化的事件以及LyraCharacter死亡的事件，接下来我们继续沿着这条路线往下，看看Lyra是如何处理HealthAttribute的变化的展示的。

##### 1.2.1 HealthComponent

​	**HealthSet**的OnHealthChanged委托的**回调函数的绑定**的时机在ULyraHealthComponent::InitializeWithAbilitySystem中，这个就是一个HealthComponent的初始化的地方，而这个函数的唯一的调用时机是在LyraCharacter中，可知这个Component是挂在LyraCharacter上的，也确实合理，毕竟Character死了之后Health的展示也无从谈起了。InitializeWithAbilitySystem这个函数的调用比较地神奇，没看懂在干嘛，反正大概就是在Character上的ASC指针绑定了指向到PlayerState上的正统ASC之后，LyraCharacter就有了一个有效的ASC，然后就可以对HealthComponent进行安全的初始化。

LyraCharacter中的HealthComponent成员：

![image-20250130010652663](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250130010652663.png)

.h

```c++
#include "Components/GameFrameworkComponent.h"

#include "LyraHealthComponent.generated.h"

class ULyraHealthComponent;

class ULyraAbilitySystemComponent;
class ULyraHealthSet;
class UObject;
struct FFrame;
struct FGameplayEffectSpec;

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FLyraHealth_DeathEvent, AActor*, OwningActor);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_FourParams(FLyraHealth_AttributeChanged, ULyraHealthComponent*, HealthComponent, float, OldValue, float, NewValue, AActor*, Instigator);

/**
 * ELyraDeathState
 *
 *  Defines current state of death.
 */
UENUM(BlueprintType)
enum class ELyraDeathState : uint8
{
    NotDead = 0,
    DeathStarted,
    DeathFinished
};


/**
 * ULyraHealthComponent
 *
 *  An actor component used to handle anything related to health.
 */
UCLASS(Blueprintable, Meta=(BlueprintSpawnableComponent))
class LYRAGAME_API ULyraHealthComponent : public UGameFrameworkComponent
{
    GENERATED_BODY()

public:

    ULyraHealthComponent(const FObjectInitializer& ObjectInitializer);

    // Returns the health component if one exists on the specified actor.
    UFUNCTION(BlueprintPure, Category = "Lyra|Health")
    static ULyraHealthComponent* FindHealthComponent(const AActor* Actor) { return (Actor ? Actor->FindComponentByClass<ULyraHealthComponent>() : nullptr); }

    // Initialize the component using an ability system component.
    UFUNCTION(BlueprintCallable, Category = "Lyra|Health")
    void InitializeWithAbilitySystem(ULyraAbilitySystemComponent* InASC);

    // Uninitialize the component, clearing any references to the ability system.
    UFUNCTION(BlueprintCallable, Category = "Lyra|Health")
    void UninitializeFromAbilitySystem();

    // Returns the current health value.
    UFUNCTION(BlueprintCallable, Category = "Lyra|Health")
    float GetHealth() const;

    // Returns the current maximum health value.
    UFUNCTION(BlueprintCallable, Category = "Lyra|Health")
    float GetMaxHealth() const;

    // Returns the current health in the range [0.0, 1.0].
    UFUNCTION(BlueprintCallable, Category = "Lyra|Health")
    float GetHealthNormalized() const;

    UFUNCTION(BlueprintCallable, Category = "Lyra|Health")
    ELyraDeathState GetDeathState() const { return DeathState; }

    UFUNCTION(BlueprintCallable, BlueprintPure = false, Category = "Lyra|Health", Meta = (ExpandBoolAsExecs = "ReturnValue"))
    bool IsDeadOrDying() const { return (DeathState > ELyraDeathState::NotDead); }

    // Begins the death sequence for the owner.
    virtual void StartDeath();

    // Ends the death sequence for the owner.
    virtual void FinishDeath();

    // Applies enough damage to kill the owner.
    virtual void DamageSelfDestruct(bool bFellOutOfWorld = false);

public:

    // Delegate fired when the health value has changed. This is called on the client but the instigator may not be valid
    UPROPERTY(BlueprintAssignable)
    FLyraHealth_AttributeChanged OnHealthChanged;

    // Delegate fired when the max health value has changed. This is called on the client but the instigator may not be valid
    UPROPERTY(BlueprintAssignable)
    FLyraHealth_AttributeChanged OnMaxHealthChanged;

    // Delegate fired when the death sequence has started.
    UPROPERTY(BlueprintAssignable)
    FLyraHealth_DeathEvent OnDeathStarted;

    // Delegate fired when the death sequence has finished.
    UPROPERTY(BlueprintAssignable)
    FLyraHealth_DeathEvent OnDeathFinished;

protected:

    virtual void OnUnregister() override;

    void ClearGameplayTags();

    virtual void HandleHealthChanged(AActor* DamageInstigator, AActor* DamageCauser, const FGameplayEffectSpec* DamageEffectSpec, float DamageMagnitude, float OldValue, float NewValue);
    virtual void HandleMaxHealthChanged(AActor* DamageInstigator, AActor* DamageCauser, const FGameplayEffectSpec* DamageEffectSpec, float DamageMagnitude, float OldValue, float NewValue);
    virtual void HandleOutOfHealth(AActor* DamageInstigator, AActor* DamageCauser, const FGameplayEffectSpec* DamageEffectSpec, float DamageMagnitude, float OldValue, float NewValue);

    UFUNCTION()
    virtual void OnRep_DeathState(ELyraDeathState OldDeathState);

protected:

    // Ability system used by this component.
    UPROPERTY()
    TObjectPtr<ULyraAbilitySystemComponent> AbilitySystemComponent;

    // Health set used by this component.
    UPROPERTY()
    TObjectPtr<const ULyraHealthSet> HealthSet;

    // Replicated state used to handle dying.
    UPROPERTY(ReplicatedUsing = OnRep_DeathState)
    ELyraDeathState DeathState;
};
```

​	阅读HealthComponent的代码，其实可以发现它就像是MVC设计模式中Controller的角色，充当了Model和View之间的中间层，但是它不仅仅对View表现Health变化负责，它还涉及到了对Character死亡的逻辑负责。其中可以看到它使用了HandleHealthChanged等命名规律一样的函数来转发HealthSet中的Health相关的改变，而HealthSet中的OnHealthChanged广播的HealthChange的一个监听者就是W_HealthBar，直接就是负责Health的直观显示，但是实际上Lyra为了实现一个效果很好的GhostProgressBar其实HealthBar没有用ProgressBar，而是用了**材质实例+Widget动画**，这也是个不错的思路。Lyra没有派生自己的Widget基类，Lyra和Aura不同之处在于Aura是用了WidgetController的思路，而Lyra是用了一个Component的思路。

​	LyraHealthComponent基本上就是这些内容，接下来再来看一下另一个AttributeSet——CombatSet。

#### 1.3 CombatSet

​	通过查找用法，可以发现CombatSet出现在PlayState中作为一个属性，就和HealthSet一样。

![image-20250130104548353](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250130104548353.png)

​	此时可以注意到**PlayerState中**的初始化ASC、HealthSet和CombatSet，PlayerState中也有很多的重要的信息，待会我们再看。

```c++
ALyraPlayerState::ALyraPlayerState(const FObjectInitializer& ObjectInitializer)
    : Super(ObjectInitializer)
    , MyPlayerConnectionType(ELyraPlayerConnectionType::Player)
{
    AbilitySystemComponent = ObjectInitializer.CreateDefaultSubobject<ULyraAbilitySystemComponent>(this, TEXT("AbilitySystemComponent"));
    AbilitySystemComponent->SetIsReplicated(true);
    AbilitySystemComponent->SetReplicationMode(EGameplayEffectReplicationMode::Mixed);

    // These attribute sets will be detected by AbilitySystemComponent::InitializeComponent. Keeping a reference so that the sets don't get garbage collected before that.
    HealthSet = CreateDefaultSubobject<ULyraHealthSet>(TEXT("HealthSet"));
    CombatSet = CreateDefaultSubobject<ULyraCombatSet>(TEXT("CombatSet"));

    // AbilitySystemComponent needs to be updated at a high frequency.
    SetNetUpdateFrequency(100.0f);

    MyTeamID = FGenericTeamId::NoTeam;
    MySquadID = INDEX_NONE;
}
```

​	可以看到初始化AttributeSet的时候上面的注释提示说，ASC会自己去找到AttributeSet，所以无需自己设置依赖，这是不错的。

​	CombatSet的内容相当简单：

.h

```c++
#include "AbilitySystemComponent.h"
#include "LyraAttributeSet.h"

#include "LyraCombatSet.generated.h"

class UObject;
struct FFrame;


/**
 * ULyraCombatSet
 *
 *  Class that defines attributes that are necessary for applying damage or healing.
 *  Attribute examples include: damage, healing, attack power, and shield penetrations.
 */
UCLASS(BlueprintType)
class ULyraCombatSet : public ULyraAttributeSet
{
    GENERATED_BODY()

public:

    ULyraCombatSet();

    ATTRIBUTE_ACCESSORS(ULyraCombatSet, BaseDamage);
    ATTRIBUTE_ACCESSORS(ULyraCombatSet, BaseHeal);

protected:

    UFUNCTION()
    void OnRep_BaseDamage(const FGameplayAttributeData& OldValue);

    UFUNCTION()
    void OnRep_BaseHeal(const FGameplayAttributeData& OldValue);

private:

    // The base amount of damage to apply in the damage execution.
    UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_BaseDamage, Category = "Lyra|Combat", Meta = (AllowPrivateAccess = true))
    FGameplayAttributeData BaseDamage;

    // The base amount of healing to apply in the heal execution.
    UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_BaseHeal, Category = "Lyra|Combat", Meta = (AllowPrivateAccess = true))
    FGameplayAttributeData BaseHeal;
};
```

.cpp

```c++
#include "LyraCombatSet.h"

#include "AbilitySystem/Attributes/LyraAttributeSet.h"
#include "Net/UnrealNetwork.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(LyraCombatSet)

class FLifetimeProperty;


ULyraCombatSet::ULyraCombatSet()
    : BaseDamage(0.0f)
    , BaseHeal(0.0f)
{
}

void ULyraCombatSet::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
    Super::GetLifetimeReplicatedProps(OutLifetimeProps);

    DOREPLIFETIME_CONDITION_NOTIFY(ULyraCombatSet, BaseDamage, COND_OwnerOnly, REPNOTIFY_Always);
    DOREPLIFETIME_CONDITION_NOTIFY(ULyraCombatSet, BaseHeal, COND_OwnerOnly, REPNOTIFY_Always);
}

void ULyraCombatSet::OnRep_BaseDamage(const FGameplayAttributeData& OldValue)
{
    GAMEPLAYATTRIBUTE_REPNOTIFY(ULyraCombatSet, BaseDamage, OldValue);
}

void ULyraCombatSet::OnRep_BaseHeal(const FGameplayAttributeData& OldValue)
{
    GAMEPLAYATTRIBUTE_REPNOTIFY(ULyraCombatSet, BaseHeal, OldValue);
}
```

​	CombatSet中的Attribute主要用在**进行GE的计算**时使用，其中的Damage出现在Lyra的LyraDamageExecution中，这是一个GE的Execution计算类，Execution和MMC很类似，但是Execution有不同之处在于它可以修改多个Attributes，MMC属于Modifier，但Execution就是自己Execution在LyraDamageExecution中，CombatSet中的Damage被用于作为基础伤害，进行了涉及随距离的伤害衰减等参数运算后输出为最终的单次攻击的伤害：

![image-20250130112600633](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250130112600633.png)

​	BTW：再往下深扒LyraRangedWeapon的造成伤害的逻辑，发现它本质上其实就是在激活GA_Weapon_Fire_SpecificWeapon（特定的一个武器的射击GA）用**射线检测**去获取射击命中的目标（这是写在GA_Weapon_Fire的C++基类LyraGameplayAbilityRangedWeapon中C++内部完成的东西，实际上不仅仅只是射线检测那么简单，还涉及到了子弹散布等判定），然后把特定武器继承自GA_Weapon_Fire这个GA的特定中的一个GE成员变量在该武器中设置的默认值（GE_Damage）Apply给**命中的目标**。例如这是Pistol的GE_Damage。

![image-20250130113803749](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250130113803749.png)

​	Lyra的GE有一定的派生关系，但是Lyra只是从GAS原来的GameplayEffect中派生出自己的蓝图的GE，并没有去自己多派生一层给GE多增加东西，主要的意义是可以制作一些基类，相同类型的GE有部分相同的GameplayTag和持续时间策略，例如Pistol和Shootgun等等远程武器有共享的一些Tag，以及GE的持续时间策略都是Instant，这样做方便管理本质同类的GE并且可以复用一些设置：

GameplayEffectParent_Damage_Basic（继承自GameplayEffect）的设置：

![image-20250130115739528](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250130115739528.png)

GE_Damage_Basic_Instant（继承自上面这个GE）

![image-20250130115959289](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250130115959289.png)

> [!WARNING]
>
> ​	我找了半天也没找到Lyra在游戏中是如何修改Character的BaseDamage和BaseHeal的，打开Debug AbilitySystem一看也发现都是0，但是这样的话怎么造成伤害？？？

> [!NOTE]
>
> ​	以上问题已解决，原来是直接在GE中定义的，Weapon的GE会在开火的时候直接把一个float值加给Character的CombatSet中的BaseDamage，这样就使得Character只有在进行攻击时才会有BaseDamage……有点神奇的思路只能说。像这里可以看到Pistol的GE_Damage_Pistol就在对目标造成伤害的时候给攻击的发起者了一个BaseDamage的瞬时的添加，使得攻击的发起者可以用Pistol造成18的伤害。

![image-20250130181239731](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250130181239731.png)

## PART III LyraInput系统

### 1. InputConfig

​	Lyra的Input设计得很有意思，InputAction会和一个InputTag（其实是一个FGameplayTag）进行绑定，绑定的信息在DataAsset——LyraInputConfig中通过两个数组来定义。这两个数组的元素都是结构体FLyraInputAction

LyraInputConfig.h

```c++
#include "Engine/DataAsset.h"
#include "GameplayTagContainer.h"

#include "LyraInputConfig.generated.h"

class UInputAction;
class UObject;
struct FFrame;

/**
 * FLyraInputAction
 *
 *  Struct used to map a input action to a gameplay input tag.
 */
USTRUCT(BlueprintType)
struct FLyraInputAction
{
    GENERATED_BODY()

public:

    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
    TObjectPtr<const UInputAction> InputAction = nullptr;

    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Meta = (Categories = "InputTag"))
    FGameplayTag InputTag;
};

/**
 * ULyraInputConfig
 *
 *  Non-mutable data asset that contains input configuration properties.
 */
UCLASS(BlueprintType, Const)
class ULyraInputConfig : public UDataAsset
{
    GENERATED_BODY()

public:

    ULyraInputConfig(const FObjectInitializer& ObjectInitializer);

    UFUNCTION(BlueprintCallable, Category = "Lyra|Pawn")
    const UInputAction* FindNativeInputActionForTag(const FGameplayTag& InputTag, bool bLogNotFound = true) const;

    UFUNCTION(BlueprintCallable, Category = "Lyra|Pawn")
    const UInputAction* FindAbilityInputActionForTag(const FGameplayTag& InputTag, bool bLogNotFound = true) const;

public:
    // List of input actions used by the owner.  These input actions are mapped to a gameplay tag and must be manually bound.
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Meta = (TitleProperty = "InputAction"))
    TArray<FLyraInputAction> NativeInputActions;

    // List of input actions used by the owner.  These input actions are mapped to a gameplay tag and are automatically bound to abilities with matching input tags.
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Meta = (TitleProperty = "InputAction"))
    TArray<FLyraInputAction> AbilityInputActions;
};
```

​	看这两个数组，NativeInputAction管的是那些不需要做成Ability的那些行为，例如Character的Move；而AbilityInputActions管的是那些做成了Ability的行为，例如Fire。这点只要打开InputData_Hero就一目了然了：

![image-20250131000453131](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250131000453131.png)

​	而且不难发现，Lyra的部分IA的命名和InputTag的命名的规律是一样的，遵循了相同的层级结构。除了像Jump、Weapon相关的IA。

​	我们不难找出其他的InputConfig，不同的InputConfig中给出了不同的LyraInputAction，通过给Character配置不同的InputConfig，就能实现指定Character被许可进行的有效的InputAction。

​	简单看下InputConfig的cpp，就是给出了两种依据InputTag找出TArray中对应的InputAction的方法。

```c++
#include "LyraInputConfig.h"

#include "LyraLogChannels.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(LyraInputConfig)


ULyraInputConfig::ULyraInputConfig(const FObjectInitializer& ObjectInitializer)
{
}

const UInputAction* ULyraInputConfig::FindNativeInputActionForTag(const FGameplayTag& InputTag, bool bLogNotFound) const
{
    for (const FLyraInputAction& Action : NativeInputActions)
    {
       if (Action.InputAction && (Action.InputTag == InputTag))
       {
          return Action.InputAction;
       }
    }

    if (bLogNotFound)
    {
       UE_LOG(LogLyra, Error, TEXT("Can't find NativeInputAction for InputTag [%s] on InputConfig [%s]."), *InputTag.ToString(), *GetNameSafe(this));
    }

    return nullptr;
}

const UInputAction* ULyraInputConfig::FindAbilityInputActionForTag(const FGameplayTag& InputTag, bool bLogNotFound) const
{
    for (const FLyraInputAction& Action : AbilityInputActions)
    {
       if (Action.InputAction && (Action.InputTag == InputTag))
       {
          return Action.InputAction;
       }
    }

    if (bLogNotFound)
    {
       UE_LOG(LogLyra, Error, TEXT("Can't find AbilityInputAction for InputTag [%s] on InputConfig [%s]."), *InputTag.ToString(), *GetNameSafe(this));
    }

    return nullptr;
}
```

#### 1.1 InputConfig和LyraPawnData

​	InputConfig在LyraPawnData中被使用，PawnData主要维护了几个和LyraPawn有关的字段，直接看.h

```c++
#pragma once

#include "Engine/DataAsset.h"

#include "LyraPawnData.generated.h"

class APawn;
class ULyraAbilitySet;
class ULyraAbilityTagRelationshipMapping;
class ULyraCameraMode;
class ULyraInputConfig;
class UObject;


/**
 * ULyraPawnData
 *
 *  Non-mutable data asset that contains properties used to define a pawn.
 */
UCLASS(BlueprintType, Const, Meta = (DisplayName = "Lyra Pawn Data", ShortTooltip = "Data asset used to define a Pawn."))
class LYRAGAME_API ULyraPawnData : public UPrimaryDataAsset
{
    GENERATED_BODY()

public:

    ULyraPawnData(const FObjectInitializer& ObjectInitializer);

public:

    // Class to instantiate for this pawn (should usually derive from ALyraPawn or ALyraCharacter).
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Lyra|Pawn")
    TSubclassOf<APawn> PawnClass;

    // Ability sets to grant to this pawn's ability system.
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Lyra|Abilities")
    TArray<TObjectPtr<ULyraAbilitySet>> AbilitySets;

    // What mapping of ability tags to use for actions taking by this pawn
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Lyra|Abilities")
    TObjectPtr<ULyraAbilityTagRelationshipMapping> TagRelationshipMapping;

    // Input configuration used by player controlled pawns to create input mappings and bind input actions.
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Lyra|Input")
    TObjectPtr<ULyraInputConfig> InputConfig;

    // Default camera mode used by player controlled pawns.
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Lyra|Camera")
    TSubclassOf<ULyraCameraMode> DefaultCameraMode;
};
```

​	LyraPawnData应该是用来初始化Pawn的信息，它派生自PrimaryDataAsset，可以派生蓝图类，其中一个字段AbilitySet中涉及到了要授予Pawn的GameplayAbilities以及GameplayEffects和AttributeSet，可见LyraPawnData和Lyra中的Character的初始化息息相关。

​	再细究PawnData的用处，通过在Rider中查找PawnData的用法，可以发现PawnData出现在了很多的类中，例如LyraPlayerState、LyraExperienceDefinition、LyraPawnExtensionComponent中都有PawnData的一个指针成员变量。

##### 1.1.1 LyraPawnData的起源

​	经过一番苦苦追寻，我终于发现了LyraPawnData起源自LyraExperienceDefinition，Lyra中的Experience有点像是游戏的部分规则，它是一个PrimaryDataAsset的子类，以下是它的.h：

```c++
#include "Engine/DataAsset.h"
#include "LyraExperienceDefinition.generated.h"

class UGameFeatureAction;
class ULyraPawnData;
class ULyraExperienceActionSet;

/**
 * Definition of an experience
 */
UCLASS(BlueprintType, Const)
class ULyraExperienceDefinition : public UPrimaryDataAsset
{
    GENERATED_BODY()

public:
    ULyraExperienceDefinition();

    //~UObject interface
#if WITH_EDITOR
    virtual EDataValidationResult IsDataValid(class FDataValidationContext& Context) const override;
#endif
    //~End of UObject interface

    //~UPrimaryDataAsset interface
#if WITH_EDITORONLY_DATA
    virtual void UpdateAssetBundleData() override;
#endif
    //~End of UPrimaryDataAsset interface

public:
    // List of Game Feature Plugins this experience wants to have active
    UPROPERTY(EditDefaultsOnly, Category = Gameplay)
    TArray<FString> GameFeaturesToEnable;

    /** The default pawn class to spawn for players */
    //@TODO: Make soft?
    UPROPERTY(EditDefaultsOnly, Category=Gameplay)
    TObjectPtr<const ULyraPawnData> DefaultPawnData;

    // List of actions to perform as this experience is loaded/activated/deactivated/unloaded
    UPROPERTY(EditDefaultsOnly, Instanced, Category="Actions")
    TArray<TObjectPtr<UGameFeatureAction>> Actions;

    // List of additional action sets to compose into this experience
    UPROPERTY(EditDefaultsOnly, Category=Gameplay)
    TArray<TObjectPtr<ULyraExperienceActionSet>> ActionSets;
};
```

​	Lyra会先在PlayerState中几乎算是初始化的地方试图为PlayerState根据一个给定的LyraExperienceDefinition中的DefaultPanwData去初始化PlayerState中的PawnData指针。具体的有关逻辑如下：

```c++
void ALyraPlayerState::OnExperienceLoaded(const ULyraExperienceDefinition* /*CurrentExperience*/)
{
    if (ALyraGameMode* LyraGameMode = GetWorld()->GetAuthGameMode<ALyraGameMode>())
    {
       if (const ULyraPawnData* NewPawnData = LyraGameMode->GetPawnDataForController(GetOwningController()))
       {
          SetPawnData(NewPawnData);
       }
       else
       {
          UE_LOG(LogLyra, Error, TEXT("ALyraPlayerState::OnExperienceLoaded(): Unable to find PawnData to initialize player state [%s]!"), *GetNameSafe(this));
       }
    }
}
```

​	首先当ExperienceLoaded的时候，会初始化PlayerState中的PawnData，这里看似是通过GameMode从Controller获得PawnData的信息，实际上此时这两个人自己的PawnData指针都没初始化，Controller的PawnData都是来自于PlayerState，其实这里是采取了PlayerState上不存在PawnData就去问ExperienceDefinition要的逻辑。说实话这个套娃逻辑某种程度上来说有点抽象。这里的ExperienceLoad的逻辑比较复杂，就暂且当作是游戏准备开始的事前准备就ok了。

```c++
const ULyraPawnData* ALyraGameMode::GetPawnDataForController(const AController* InController) const
{
    // See if pawn data is already set on the player state
    if (InController != nullptr)
    {
       if (const ALyraPlayerState* LyraPS = InController->GetPlayerState<ALyraPlayerState>())
       {
          if (const ULyraPawnData* PawnData = LyraPS->GetPawnData<ULyraPawnData>())
          {
             return PawnData;
          }
       }
    }

    // If not, fall back to the the default for the current experience
    check(GameState);
    ULyraExperienceManagerComponent* ExperienceComponent = GameState->FindComponentByClass<ULyraExperienceManagerComponent>();
    check(ExperienceComponent);

    if (ExperienceComponent->IsExperienceLoaded())
    {
       const ULyraExperienceDefinition* Experience = ExperienceComponent->GetCurrentExperienceChecked();
       if (Experience->DefaultPawnData != nullptr)
       {
          return Experience->DefaultPawnData;
       }

       // Experience is loaded and there's still no pawn data, fall back to the default for now
       return ULyraAssetManager::Get().GetDefaultPawnData();
    }

    // Experience not loaded yet, so there is no pawn data to be had
    return nullptr;
}
```

​	当PlayerState拿到当前的ExperienceDefinition所设置的PawnData后，它就相当于一个拥有PawnData的代言人了，接下来我们再去找PawnData在哪里被用来初始化Character的输入逻辑也就是PawnData的InputConfig在哪里被使用来初始化了，这是我们最关心的。

##### 1.1.2 LyraPawnData如何发挥作用

​	我又一路追溯来到了LyraHeroComponent，终于发现了PawnData用于初始化Character的地方，就是在此：

```c++
void ULyraHeroComponent::HandleChangeInitState(UGameFrameworkComponentManager* Manager, FGameplayTag CurrentState, FGameplayTag DesiredState)
{
    if (CurrentState == LyraGameplayTags::InitState_DataAvailable && DesiredState == LyraGameplayTags::InitState_DataInitialized)
    {
       APawn* Pawn = GetPawn<APawn>();
       ALyraPlayerState* LyraPS = GetPlayerState<ALyraPlayerState>();
       if (!ensure(Pawn && LyraPS))
       {
          return;
       }

       const ULyraPawnData* PawnData = nullptr;

       if (ULyraPawnExtensionComponent* PawnExtComp = ULyraPawnExtensionComponent::FindPawnExtensionComponent(Pawn))
       {
          PawnData = PawnExtComp->GetPawnData<ULyraPawnData>();

          // The player state holds the persistent data for this player (state that persists across deaths and multiple pawns).
          // The ability system component and attribute sets live on the player state.
          PawnExtComp->InitializeAbilitySystem(LyraPS->GetLyraAbilitySystemComponent(), LyraPS);
       }

       if (ALyraPlayerController* LyraPC = GetController<ALyraPlayerController>())
       {
          if (Pawn->InputComponent != nullptr)
          {
             InitializePlayerInput(Pawn->InputComponent);
          }
       }

       // Hook up the delegate for all pawns, in case we spectate later
       if (PawnData)
       {
          if (ULyraCameraComponent* CameraComponent = ULyraCameraComponent::FindCameraComponent(Pawn))
          {
             CameraComponent->DetermineCameraModeDelegate.BindUObject(this, &ThisClass::DetermineCameraMode);
          }
       }
    }
}
```

​	这里出现了一个很有意义的注释，这段注释道出了众多的信息。（这里稍微有点偏题了，注意力继续回到PawnConfig上！

```c++
// The player state holds the persistent data for this player (state that persists across deaths and multiple pawns).
          // The ability system component and attribute sets live on the player state.
```

​	我们注意到此时这里虽然出场了PawnData，但是PawnData中的InputConfig却没有出场，但是我们能注意到和InputConfig关系密切的InputComponent出现了！我们要接近答案了！！！

![image-20250131011830762](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250131011830762.png)

##### 1.1.3 InputConfig的目的地

​	可以看到这个InitializePlayerInput是HeroComponent的一个成员函数，它的名字预示着答案的降临！查看它的定义：

```c++
void ULyraHeroComponent::InitializePlayerInput(UInputComponent* PlayerInputComponent)
{
    check(PlayerInputComponent);

    const APawn* Pawn = GetPawn<APawn>();
    if (!Pawn)
    {
       return;
    }

    const APlayerController* PC = GetController<APlayerController>();
    check(PC);

    const ULyraLocalPlayer* LP = Cast<ULyraLocalPlayer>(PC->GetLocalPlayer());
    check(LP);

    UEnhancedInputLocalPlayerSubsystem* Subsystem = LP->GetSubsystem<UEnhancedInputLocalPlayerSubsystem>();
    check(Subsystem);

    Subsystem->ClearAllMappings();

    if (const ULyraPawnExtensionComponent* PawnExtComp = ULyraPawnExtensionComponent::FindPawnExtensionComponent(Pawn))
    {
       if (const ULyraPawnData* PawnData = PawnExtComp->GetPawnData<ULyraPawnData>())
       {
          if (const ULyraInputConfig* InputConfig = PawnData->InputConfig)
          {
             for (const FInputMappingContextAndPriority& Mapping : DefaultInputMappings)
             {
                if (UInputMappingContext* IMC = Mapping.InputMapping.Get())
                {
                   if (Mapping.bRegisterWithSettings)
                   {
                      if (UEnhancedInputUserSettings* Settings = Subsystem->GetUserSettings())
                      {
                         Settings->RegisterInputMappingContext(IMC);
                      }
                      
                      FModifyContextOptions Options = {};
                      Options.bIgnoreAllPressedKeysUntilRelease = false;
                      // Actually add the config to the local player                   
                      Subsystem->AddMappingContext(IMC, Mapping.Priority, Options);
                   }
                }
             }

             // The Lyra Input Component has some additional functions to map Gameplay Tags to an Input Action.
             // If you want this functionality but still want to change your input component class, make it a subclass
             // of the ULyraInputComponent or modify this component accordingly.
             ULyraInputComponent* LyraIC = Cast<ULyraInputComponent>(PlayerInputComponent);
             if (ensureMsgf(LyraIC, TEXT("Unexpected Input Component class! The Gameplay Abilities will not be bound to their inputs. Change the input component to ULyraInputComponent or a subclass of it.")))
             {
                // Add the key mappings that may have been set by the player
                LyraIC->AddInputMappings(InputConfig, Subsystem);

                // This is where we actually bind and input action to a gameplay tag, which means that Gameplay Ability Blueprints will
                // be triggered directly by these input actions Triggered events. 
                TArray<uint32> BindHandles;
                LyraIC->BindAbilityActions(InputConfig, this, &ThisClass::Input_AbilityInputTagPressed, &ThisClass::Input_AbilityInputTagReleased, /*out*/ BindHandles);

                LyraIC->BindNativeAction(InputConfig, LyraGameplayTags::InputTag_Move, ETriggerEvent::Triggered, this, &ThisClass::Input_Move, /*bLogIfNotFound=*/ false);
                LyraIC->BindNativeAction(InputConfig, LyraGameplayTags::InputTag_Look_Mouse, ETriggerEvent::Triggered, this, &ThisClass::Input_LookMouse, /*bLogIfNotFound=*/ false);
                LyraIC->BindNativeAction(InputConfig, LyraGameplayTags::InputTag_Look_Stick, ETriggerEvent::Triggered, this, &ThisClass::Input_LookStick, /*bLogIfNotFound=*/ false);
                LyraIC->BindNativeAction(InputConfig, LyraGameplayTags::InputTag_Crouch, ETriggerEvent::Triggered, this, &ThisClass::Input_Crouch, /*bLogIfNotFound=*/ false);
                LyraIC->BindNativeAction(InputConfig, LyraGameplayTags::InputTag_AutoRun, ETriggerEvent::Triggered, this, &ThisClass::Input_AutoRun, /*bLogIfNotFound=*/ false);
             }
          }
       }
    }
    
	if (ensure(!bReadyToBindInputs))
	{
		bReadyToBindInputs = true;
	}
 
	UGameFrameworkComponentManager::SendGameFrameworkComponentExtensionEvent(const_cast<APlayerController*>(PC), NAME_BindInputsNow);
	UGameFrameworkComponentManager::SendGameFrameworkComponentExtensionEvent(const_cast<APawn*>(Pawn), NAME_BindInputsNow);
}
```

​	果然！我们终于见到了LyraInputComponent的InputAction绑定的回调函数，关注到这里的BindHandles，其实根本没有用到，不知道在干嘛（汗。这里的&ThisClass::Input_AbilityInputTagPressed, &ThisClass::Input_AbilityInputTagReleased，其实本质上就是在调用AbilitySystemComponent中已经定义好了的AbilityInputTagPressed和AbilityInputTagReleased：

```c++
void ULyraHeroComponent::Input_AbilityInputTagPressed(FGameplayTag InputTag)
{
    if (const APawn* Pawn = GetPawn<APawn>())
    {
       if (const ULyraPawnExtensionComponent* PawnExtComp = ULyraPawnExtensionComponent::FindPawnExtensionComponent(Pawn))
       {
          if (ULyraAbilitySystemComponent* LyraASC = PawnExtComp->GetLyraAbilitySystemComponent())
          {
             LyraASC->AbilityInputTagPressed(InputTag);
          }
       }  
    }
}

void ULyraHeroComponent::Input_AbilityInputTagReleased(FGameplayTag InputTag)
{
    const APawn* Pawn = GetPawn<APawn>();
    if (!Pawn)
    {
       return;
    }

    if (const ULyraPawnExtensionComponent* PawnExtComp = ULyraPawnExtensionComponent::FindPawnExtensionComponent(Pawn))
    {
       if (ULyraAbilitySystemComponent* LyraASC = PawnExtComp->GetLyraAbilitySystemComponent())
       {
          LyraASC->AbilityInputTagReleased(InputTag);
       }
    }
}
```

​	此外还可以继续在LyraHeroComponent.cpp往下找，找到那些绑定NativeInputAction的函数：

```c++
void ULyraHeroComponent::Input_Move(const FInputActionValue& InputActionValue)
{
    APawn* Pawn = GetPawn<APawn>();
    AController* Controller = Pawn ? Pawn->GetController() : nullptr;

    // If the player has attempted to move again then cancel auto running
    if (ALyraPlayerController* LyraController = Cast<ALyraPlayerController>(Controller))
    {
       LyraController->SetIsAutoRunning(false);
    }
    
    if (Controller)
    {
       const FVector2D Value = InputActionValue.Get<FVector2D>();
       const FRotator MovementRotation(0.0f, Controller->GetControlRotation().Yaw, 0.0f);

       if (Value.X != 0.0f)
       {
          const FVector MovementDirection = MovementRotation.RotateVector(FVector::RightVector);
          Pawn->AddMovementInput(MovementDirection, Value.X);
       }

       if (Value.Y != 0.0f)
       {
          const FVector MovementDirection = MovementRotation.RotateVector(FVector::ForwardVector);
          Pawn->AddMovementInput(MovementDirection, Value.Y);
       }
    }
}

void ULyraHeroComponent::Input_LookMouse(const FInputActionValue& InputActionValue)
{
    APawn* Pawn = GetPawn<APawn>();

    if (!Pawn)
    {
       return;
    }
    
    const FVector2D Value = InputActionValue.Get<FVector2D>();

    if (Value.X != 0.0f)
    {
       Pawn->AddControllerYawInput(Value.X);
    }

    if (Value.Y != 0.0f)
    {
       Pawn->AddControllerPitchInput(Value.Y);
    }
}

void ULyraHeroComponent::Input_LookStick(const FInputActionValue& InputActionValue)
{
    APawn* Pawn = GetPawn<APawn>();

    if (!Pawn)
    {
       return;
    }
    
    const FVector2D Value = InputActionValue.Get<FVector2D>();

    const UWorld* World = GetWorld();
    check(World);

    if (Value.X != 0.0f)
    {
       Pawn->AddControllerYawInput(Value.X * LyraHero::LookYawRate * World->GetDeltaSeconds());
    }

    if (Value.Y != 0.0f)
    {
       Pawn->AddControllerPitchInput(Value.Y * LyraHero::LookPitchRate * World->GetDeltaSeconds());
    }
}

void ULyraHeroComponent::Input_Crouch(const FInputActionValue& InputActionValue)
{
    if (ALyraCharacter* Character = GetPawn<ALyraCharacter>())
    {
       Character->ToggleCrouch();
    }
}

void ULyraHeroComponent::Input_AutoRun(const FInputActionValue& InputActionValue)
{
    if (APawn* Pawn = GetPawn<APawn>())
    {
       if (ALyraPlayerController* Controller = Cast<ALyraPlayerController>(Pawn->GetController()))
       {
          // Toggle auto running
          Controller->SetIsAutoRunning(!Controller->GetIsAutoRunning());
       }  
    }
}
```

​	我们的注意力来到LyraAbilitySystemComponent中的AbilityInputTagPressed和AbilityInputTagReleased的实现：

```c++
void ULyraAbilitySystemComponent::AbilityInputTagPressed(const FGameplayTag& InputTag)
{
    if (InputTag.IsValid())
    {
       for (const FGameplayAbilitySpec& AbilitySpec : ActivatableAbilities.Items)
       {
          if (AbilitySpec.Ability && (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)))
          {
             InputPressedSpecHandles.AddUnique(AbilitySpec.Handle);
             InputHeldSpecHandles.AddUnique(AbilitySpec.Handle);
          }
       }
    }
}

void ULyraAbilitySystemComponent::AbilityInputTagReleased(const FGameplayTag& InputTag)
{
    if (InputTag.IsValid())
    {
       for (const FGameplayAbilitySpec& AbilitySpec : ActivatableAbilities.Items)
       {
          if (AbilitySpec.Ability && (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)))
          {
             InputReleasedSpecHandles.AddUnique(AbilitySpec.Handle);
             InputHeldSpecHandles.Remove(AbilitySpec.Handle);
          }
       }
    }
}
```

​	我们会发现实际上它们俩是会去遍历本ASC中的可激活的Abilities，检查其DynamicAbilityTags中是否带有对应于输入的Tag，如果有，就把该AbilitySpec的Handle添加到或移除出InputHeldSpecHandles，并且把它们放在分别的两个存储Handles的数组中统一处理，这些AbilitySpecHandle的统一处理在另一个ASC的函数中，待会再看。	

> [!NOTE]
>
> ​	实际上这个方法和在Aura中学到的其实是**完全一样的**，只不过Aura的教学版本是5.2，当时还是通过直接访问AbilitySpec.DynamicAbilityTgas,在5.5版本的Lyra中弃用了直接访问DynamicAbilityTags的做法转而采取使用一个Getter函数GetDynamicSpecSourseTags来间接访问它。

​	现在我们知道了ASC有能力根据不同的InputTag的输入，去执行不同的GameplayAbility，但是这样的联系是如何做到的呢？我们在编辑器中先从**InputData_Hero**了解到InputTag.Weapon.Fire和IA_Weapon_Fire相关联，我们又搜索InputTag.Weapon.Fire的引用关系，发现它被唯一的GameplayAbility引用是被GA_WeaponFire，一切都对上了！！！

![image-20250131110751153](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250131110751153.png)

​	它并不是出现在表面上的GA的各种Tag中，而是出现在了”触发器“中：

![image-20250131111255550](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250131111255550.png)

#### 1.2 AbilitySet和InputTag的关联

##### 1.2.1 InputTag与GameplayAbility的绑定之处

​	但是！这并不是决定通过InputTag触发特定GameplayAbility的地方，取消这里的触发标签并不会影响你在Lyra中开枪。决定它们的响应关系的地方是在LyraAbilitySet中的GiveToAbilitySystem函数中！！！

![image-20250131112350900](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250131112350900.png)

​	GiveToAbilitySystem函数的完整实现：

```c++
void ULyraAbilitySet::GiveToAbilitySystem(ULyraAbilitySystemComponent* LyraASC, FLyraAbilitySet_GrantedHandles* OutGrantedHandles, UObject* SourceObject) const
{
    check(LyraASC);

    if (!LyraASC->IsOwnerActorAuthoritative())
    {
       // Must be authoritative to give or take ability sets.
       return;
    }
    
    // Grant the attribute sets.
    for (int32 SetIndex = 0; SetIndex < GrantedAttributes.Num(); ++SetIndex)
    {
       const FLyraAbilitySet_AttributeSet& SetToGrant = GrantedAttributes[SetIndex];

       if (!IsValid(SetToGrant.AttributeSet))
       {
          UE_LOG(LogLyraAbilitySystem, Error, TEXT("GrantedAttributes[%d] on ability set [%s] is not valid"), SetIndex, *GetNameSafe(this));
          continue;
       }

       UAttributeSet* NewSet = NewObject<UAttributeSet>(LyraASC->GetOwner(), SetToGrant.AttributeSet);
       LyraASC->AddAttributeSetSubobject(NewSet);

       if (OutGrantedHandles)
       {
          OutGrantedHandles->AddAttributeSet(NewSet);
       }
    }

    // Grant the gameplay abilities.
    for (int32 AbilityIndex = 0; AbilityIndex < GrantedGameplayAbilities.Num(); ++AbilityIndex)
    {
       const FLyraAbilitySet_GameplayAbility& AbilityToGrant = GrantedGameplayAbilities[AbilityIndex];

       if (!IsValid(AbilityToGrant.Ability))
       {
          UE_LOG(LogLyraAbilitySystem, Error, TEXT("GrantedGameplayAbilities[%d] on ability set [%s] is not valid."), AbilityIndex, *GetNameSafe(this));
          continue;
       }

       ULyraGameplayAbility* AbilityCDO = AbilityToGrant.Ability->GetDefaultObject<ULyraGameplayAbility>();

       FGameplayAbilitySpec AbilitySpec(AbilityCDO, AbilityToGrant.AbilityLevel);
       AbilitySpec.SourceObject = SourceObject;
       AbilitySpec.GetDynamicSpecSourceTags().AddTag(AbilityToGrant.InputTag);

       const FGameplayAbilitySpecHandle AbilitySpecHandle = LyraASC->GiveAbility(AbilitySpec);

       if (OutGrantedHandles)
       {
          OutGrantedHandles->AddAbilitySpecHandle(AbilitySpecHandle);
       }
    }

    // Grant the gameplay effects.
    for (int32 EffectIndex = 0; EffectIndex < GrantedGameplayEffects.Num(); ++EffectIndex)
    {
       const FLyraAbilitySet_GameplayEffect& EffectToGrant = GrantedGameplayEffects[EffectIndex];

       if (!IsValid(EffectToGrant.GameplayEffect))
       {
          UE_LOG(LogLyraAbilitySystem, Error, TEXT("GrantedGameplayEffects[%d] on ability set [%s] is not valid"), EffectIndex, *GetNameSafe(this));
          continue;
       }

       const UGameplayEffect* GameplayEffect = EffectToGrant.GameplayEffect->GetDefaultObject<UGameplayEffect>();
       const FActiveGameplayEffectHandle GameplayEffectHandle = LyraASC->ApplyGameplayEffectToSelf(GameplayEffect, EffectToGrant.EffectLevel, LyraASC->MakeEffectContext());

       if (OutGrantedHandles)
       {
          OutGrantedHandles->AddGameplayEffectHandle(GameplayEffectHandle);
       }
    }
}
```

​	在AbilitySet的GiveToAbilitySystem函数中出现了将AbilityToGrant.InputTag添加加给AbilitySpec的DynamicAbilityTags，这样就实现了把AbilitySet这个PrimaryDataAsset中存有的关于GAS的三大信息：Attribute，GameplayAbility，GameplayEffect给授予给了特定目标的ASC。

#### 1.3 细探AbilitySet

​	在这里，它不仅完成了InputTag到GameplayAbility的映射关系的初始化，还会把自身携带的GE Apply到目标ASC上，可见得Lyra在ASC交互上的巧思：Lyra通过AbilitySet定义了授予目标GA、GE和Attribute的内容，这样的话，一个AbilitySet既可以用来初始化一个单位，又可以让一个Item携带有一套AbilitySet，然后在被被装备的时候授予携带的内容给目标ASC。

​	我们可以看到其丰富的应用：

![image-20250131114519381](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250131114519381.png)

![image-20250131114610464](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250131114610464.png)

![image-20250131114629184](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250131114629184.png)

​	在编辑器中查看Pistol携带的AbilitySet：

![image-20250131114734301](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250131114734301.png)

​	此外，AbilitySet中还定义了TakeFromAbilitySystem函数来处理自身被移除出ASC时的事情，但是这个函数实际上是属于结构体FLyraAbilitySet_GrantedHandles的，这个结构体是用来保存在赋予AbilitySet到ASC时授予出去的GA、GE、Attribute的一个结构体，我们再进一步了解一下它，后面直接上全部的代码：

FLyraAbilitySet_GrantedHandles::TakeFromAbilitySystem函数的定义：

```c++
void FLyraAbilitySet_GrantedHandles::TakeFromAbilitySystem(ULyraAbilitySystemComponent* LyraASC)
{
    check(LyraASC);

    if (!LyraASC->IsOwnerActorAuthoritative())
    {
       // Must be authoritative to give or take ability sets.
       return;
    }

    for (const FGameplayAbilitySpecHandle& Handle : AbilitySpecHandles)
    {
       if (Handle.IsValid())
       {
          LyraASC->ClearAbility(Handle);
       }
    }

    for (const FActiveGameplayEffectHandle& Handle : GameplayEffectHandles)
    {
       if (Handle.IsValid())
       {
          LyraASC->RemoveActiveGameplayEffect(Handle);
       }
    }

    for (UAttributeSet* Set : GrantedAttributeSets)
    {
       LyraASC->RemoveSpawnedAttribute(Set);
    }

    AbilitySpecHandles.Reset();
    GameplayEffectHandles.Reset();
    GrantedAttributeSets.Reset();
}
```

LyraAbilitySet.h

```c++
#include "ActiveGameplayEffectHandle.h"
#include "Engine/DataAsset.h"
#include "AttributeSet.h"
#include "GameplayTagContainer.h"

#include "GameplayAbilitySpecHandle.h"
#include "LyraAbilitySet.generated.h"

class UAttributeSet;
class UGameplayEffect;
class ULyraAbilitySystemComponent;
class ULyraGameplayAbility;
class UObject;


/**
 * FLyraAbilitySet_GameplayAbility
 *
 *  Data used by the ability set to grant gameplay abilities.
 */
USTRUCT(BlueprintType)
struct FLyraAbilitySet_GameplayAbility
{
    GENERATED_BODY()

public:

    // Gameplay ability to grant.
    UPROPERTY(EditDefaultsOnly)
    TSubclassOf<ULyraGameplayAbility> Ability = nullptr;

    // Level of ability to grant.
    UPROPERTY(EditDefaultsOnly)
    int32 AbilityLevel = 1;

    // Tag used to process input for the ability.
    UPROPERTY(EditDefaultsOnly, Meta = (Categories = "InputTag"))
    FGameplayTag InputTag;
};


/**
 * FLyraAbilitySet_GameplayEffect
 *
 *  Data used by the ability set to grant gameplay effects.
 */
USTRUCT(BlueprintType)
struct FLyraAbilitySet_GameplayEffect
{
    GENERATED_BODY()

public:

    // Gameplay effect to grant.
    UPROPERTY(EditDefaultsOnly)
    TSubclassOf<UGameplayEffect> GameplayEffect = nullptr;

    // Level of gameplay effect to grant.
    UPROPERTY(EditDefaultsOnly)
    float EffectLevel = 1.0f;
};

/**
 * FLyraAbilitySet_AttributeSet
 *
 *  Data used by the ability set to grant attribute sets.
 */
USTRUCT(BlueprintType)
struct FLyraAbilitySet_AttributeSet
{
    GENERATED_BODY()

public:
    // Gameplay effect to grant.
    UPROPERTY(EditDefaultsOnly)
    TSubclassOf<UAttributeSet> AttributeSet;

};

/**
 * FLyraAbilitySet_GrantedHandles
 *
 *  Data used to store handles to what has been granted by the ability set.
 */
USTRUCT(BlueprintType)
struct FLyraAbilitySet_GrantedHandles
{
    GENERATED_BODY()

public:

    void AddAbilitySpecHandle(const FGameplayAbilitySpecHandle& Handle);
    void AddGameplayEffectHandle(const FActiveGameplayEffectHandle& Handle);
    void AddAttributeSet(UAttributeSet* Set);

    void TakeFromAbilitySystem(ULyraAbilitySystemComponent* LyraASC);

protected:

    // Handles to the granted abilities.
    UPROPERTY()
    TArray<FGameplayAbilitySpecHandle> AbilitySpecHandles;

    // Handles to the granted gameplay effects.
    UPROPERTY()
    TArray<FActiveGameplayEffectHandle> GameplayEffectHandles;

    // Pointers to the granted attribute sets
    UPROPERTY()
    TArray<TObjectPtr<UAttributeSet>> GrantedAttributeSets;
};


/**
 * ULyraAbilitySet
 *
 *  Non-mutable data asset used to grant gameplay abilities and gameplay effects.
 */
UCLASS(BlueprintType, Const)
class ULyraAbilitySet : public UPrimaryDataAsset
{
    GENERATED_BODY()

public:

    ULyraAbilitySet(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

    // Grants the ability set to the specified ability system component.
    // The returned handles can be used later to take away anything that was granted.
    void GiveToAbilitySystem(ULyraAbilitySystemComponent* LyraASC, FLyraAbilitySet_GrantedHandles* OutGrantedHandles, UObject* SourceObject = nullptr) const;

protected:

    // Gameplay abilities to grant when this ability set is granted.
    UPROPERTY(EditDefaultsOnly, Category = "Gameplay Abilities", meta=(TitleProperty=Ability))
    TArray<FLyraAbilitySet_GameplayAbility> GrantedGameplayAbilities;

    // Gameplay effects to grant when this ability set is granted.
    UPROPERTY(EditDefaultsOnly, Category = "Gameplay Effects", meta=(TitleProperty=GameplayEffect))
    TArray<FLyraAbilitySet_GameplayEffect> GrantedGameplayEffects;

    // Attribute sets to grant when this ability set is granted.
    UPROPERTY(EditDefaultsOnly, Category = "Attribute Sets", meta=(TitleProperty=AttributeSet))
    TArray<FLyraAbilitySet_AttributeSet> GrantedAttributes;
};
```

LyraAbilitySet.cpp

```c++
#include "LyraAbilitySet.h"

#include "AbilitySystem/Abilities/LyraGameplayAbility.h"
#include "LyraAbilitySystemComponent.h"
#include "LyraLogChannels.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(LyraAbilitySet)

void FLyraAbilitySet_GrantedHandles::AddAbilitySpecHandle(const FGameplayAbilitySpecHandle& Handle)
{
    if (Handle.IsValid())
    {
       AbilitySpecHandles.Add(Handle);
    }
}

void FLyraAbilitySet_GrantedHandles::AddGameplayEffectHandle(const FActiveGameplayEffectHandle& Handle)
{
    if (Handle.IsValid())
    {
       GameplayEffectHandles.Add(Handle);
    }
}

void FLyraAbilitySet_GrantedHandles::AddAttributeSet(UAttributeSet* Set)
{
    GrantedAttributeSets.Add(Set);
}

void FLyraAbilitySet_GrantedHandles::TakeFromAbilitySystem(ULyraAbilitySystemComponent* LyraASC)
{
    check(LyraASC);

    if (!LyraASC->IsOwnerActorAuthoritative())
    {
       // Must be authoritative to give or take ability sets.
       return;
    }

    for (const FGameplayAbilitySpecHandle& Handle : AbilitySpecHandles)
    {
       if (Handle.IsValid())
       {
          LyraASC->ClearAbility(Handle);
       }
    }

    for (const FActiveGameplayEffectHandle& Handle : GameplayEffectHandles)
    {
       if (Handle.IsValid())
       {
          LyraASC->RemoveActiveGameplayEffect(Handle);
       }
    }

    for (UAttributeSet* Set : GrantedAttributeSets)
    {
       LyraASC->RemoveSpawnedAttribute(Set);
    }

    AbilitySpecHandles.Reset();
    GameplayEffectHandles.Reset();
    GrantedAttributeSets.Reset();
}

ULyraAbilitySet::ULyraAbilitySet(const FObjectInitializer& ObjectInitializer)
    : Super(ObjectInitializer)
{
}

void ULyraAbilitySet::GiveToAbilitySystem(ULyraAbilitySystemComponent* LyraASC, FLyraAbilitySet_GrantedHandles* OutGrantedHandles, UObject* SourceObject) const
{
    check(LyraASC);

    if (!LyraASC->IsOwnerActorAuthoritative())
    {
       // Must be authoritative to give or take ability sets.
       return;
    }
    
    // Grant the attribute sets.
    for (int32 SetIndex = 0; SetIndex < GrantedAttributes.Num(); ++SetIndex)
    {
       const FLyraAbilitySet_AttributeSet& SetToGrant = GrantedAttributes[SetIndex];

       if (!IsValid(SetToGrant.AttributeSet))
       {
          UE_LOG(LogLyraAbilitySystem, Error, TEXT("GrantedAttributes[%d] on ability set [%s] is not valid"), SetIndex, *GetNameSafe(this));
          continue;
       }

       UAttributeSet* NewSet = NewObject<UAttributeSet>(LyraASC->GetOwner(), SetToGrant.AttributeSet);
       LyraASC->AddAttributeSetSubobject(NewSet);

       if (OutGrantedHandles)
       {
          OutGrantedHandles->AddAttributeSet(NewSet);
       }
    }

    // Grant the gameplay abilities.
    for (int32 AbilityIndex = 0; AbilityIndex < GrantedGameplayAbilities.Num(); ++AbilityIndex)
    {
       const FLyraAbilitySet_GameplayAbility& AbilityToGrant = GrantedGameplayAbilities[AbilityIndex];

       if (!IsValid(AbilityToGrant.Ability))
       {
          UE_LOG(LogLyraAbilitySystem, Error, TEXT("GrantedGameplayAbilities[%d] on ability set [%s] is not valid."), AbilityIndex, *GetNameSafe(this));
          continue;
       }

       ULyraGameplayAbility* AbilityCDO = AbilityToGrant.Ability->GetDefaultObject<ULyraGameplayAbility>();

       FGameplayAbilitySpec AbilitySpec(AbilityCDO, AbilityToGrant.AbilityLevel);
       AbilitySpec.SourceObject = SourceObject;
       AbilitySpec.GetDynamicSpecSourceTags().AddTag(AbilityToGrant.InputTag);

       const FGameplayAbilitySpecHandle AbilitySpecHandle = LyraASC->GiveAbility(AbilitySpec);

       if (OutGrantedHandles)
       {
          OutGrantedHandles->AddAbilitySpecHandle(AbilitySpecHandle);
       }
    }

    // Grant the gameplay effects.
    for (int32 EffectIndex = 0; EffectIndex < GrantedGameplayEffects.Num(); ++EffectIndex)
    {
       const FLyraAbilitySet_GameplayEffect& EffectToGrant = GrantedGameplayEffects[EffectIndex];

       if (!IsValid(EffectToGrant.GameplayEffect))
       {
          UE_LOG(LogLyraAbilitySystem, Error, TEXT("GrantedGameplayEffects[%d] on ability set [%s] is not valid"), EffectIndex, *GetNameSafe(this));
          continue;
       }

       const UGameplayEffect* GameplayEffect = EffectToGrant.GameplayEffect->GetDefaultObject<UGameplayEffect>();
       const FActiveGameplayEffectHandle GameplayEffectHandle = LyraASC->ApplyGameplayEffectToSelf(GameplayEffect, EffectToGrant.EffectLevel, LyraASC->MakeEffectContext());

       if (OutGrantedHandles)
       {
          OutGrantedHandles->AddGameplayEffectHandle(GameplayEffectHandle);
       }
    }
}
```

##### 1.3.1 AbilitySet与EquipmentDefinition

​	接着我们再查找GiveToAbilitySystem的用法，发现了它在EquipmentManagerComponent中的用法！正是在AddEntry中！！！当一件装备被装备上了之后，它的**EquipmentDefinition**上携带的AbilitySet（在EquipmentDefinition中被存在一个AbilitySet数组中，数组叫AbilitySetsToGrant）就会被授予它的装备者的ASC！并且Equipment的Entry中还有一个字段，就是一个FLyraAbilitySet_GrantedHandles，它保存了AbilitySet来时的路，保存了这件Equipment给予了目标ASC什么AbilitySet，以便后续可以在RemoveEntry中把AbilitySet带给ASC的影响**取消掉**。

​	来回顾一下EquipmentManagerComponent的AddEntry和RemoveEntry：（其实应该说是EquipmentList的函数）

```c++
ULyraEquipmentInstance* FLyraEquipmentList::AddEntry(TSubclassOf<ULyraEquipmentDefinition> EquipmentDefinition)
{
    ULyraEquipmentInstance* Result = nullptr;

    check(EquipmentDefinition != nullptr);
    check(OwnerComponent);
    check(OwnerComponent->GetOwner()->HasAuthority());
    
    const ULyraEquipmentDefinition* EquipmentCDO = GetDefault<ULyraEquipmentDefinition>(EquipmentDefinition);

    TSubclassOf<ULyraEquipmentInstance> InstanceType = EquipmentCDO->InstanceType;
    if (InstanceType == nullptr)
    {
       InstanceType = ULyraEquipmentInstance::StaticClass();
    }
    
    FLyraAppliedEquipmentEntry& NewEntry = Entries.AddDefaulted_GetRef();
    NewEntry.EquipmentDefinition = EquipmentDefinition;
    NewEntry.Instance = NewObject<ULyraEquipmentInstance>(OwnerComponent->GetOwner(), InstanceType);  //@TODO: Using the actor instead of component as the outer due to UE-127172
    Result = NewEntry.Instance;

    if (ULyraAbilitySystemComponent* ASC = GetAbilitySystemComponent())
    {
       for (const TObjectPtr<const ULyraAbilitySet>& AbilitySet : EquipmentCDO->AbilitySetsToGrant)
       {
          AbilitySet->GiveToAbilitySystem(ASC, /*inout*/ &NewEntry.GrantedHandles, Result);
       }
    }
    else
    {
       //@TODO: Warning logging?
    }

    Result->SpawnEquipmentActors(EquipmentCDO->ActorsToSpawn);


    MarkItemDirty(NewEntry);

    return Result;
}

void FLyraEquipmentList::RemoveEntry(ULyraEquipmentInstance* Instance)
{
    for (auto EntryIt = Entries.CreateIterator(); EntryIt; ++EntryIt)
    {
       FLyraAppliedEquipmentEntry& Entry = *EntryIt;
       if (Entry.Instance == Instance)
       {
          if (ULyraAbilitySystemComponent* ASC = GetAbilitySystemComponent())
          {
             Entry.GrantedHandles.TakeFromAbilitySystem(ASC);
          }

          Instance->DestroyEquipmentActors();
          

          EntryIt.RemoveCurrent();
          MarkArrayDirty();
       }
    }
}
```

​	在FLyraAppliedEquipmentEntry中我们能够找到一个**FLyraAbilitySet_GrantedHandles**成员

```c++
/** A single piece of applied equipment */
USTRUCT(BlueprintType)
struct FLyraAppliedEquipmentEntry : public FFastArraySerializerItem
{
    GENERATED_BODY()

    FLyraAppliedEquipmentEntry()
    {}

    FString GetDebugString() const;

private:
    friend FLyraEquipmentList;
    friend ULyraEquipmentManagerComponent;

    // The equipment class that got equipped
    UPROPERTY()
    TSubclassOf<ULyraEquipmentDefinition> EquipmentDefinition;

    UPROPERTY()
    TObjectPtr<ULyraEquipmentInstance> Instance = nullptr;

    // Authority-only list of granted handles
    UPROPERTY(NotReplicated)
    FLyraAbilitySet_GrantedHandles GrantedHandles;
};
```

​	现在，我们就从InputConfig出发，一路前往了AbilitySet，窥探到了其作用机制，真是十分的有趣！





## PART IV LyraInteraction

​	Lyra的Interaction的逻辑可以分成两方面，一方面是被动的交互，例如从WeaponSpawner中拾取武器，这是通过碰撞调用OnOverlapBegin的逻辑实现的。这种交互比较简单，不太复杂。

​	另一方面是通过GAS来实现，这方面的交互使用了很多的接口来实现，我们慢慢研究一下。

### 1. IInteractableTarget

​	Lyra中的交互逻辑的基础是接口类IInteractableTarget，实现了IInteractableTarget的Actor才能与Player产生交互。Lyra的Interaction的设计遵循了高度统一的一种思想，所有主动性的交互都是通过同一种实现思路，就是实现IInteractableTarget接口，而且IInteractableTarget子类各自的交互逻辑并非你写你的我写我的，而是有一套统一的逻辑，即通过**GAS的支持**来实现。

IInteractableTarget.h如下：

```c++
#pragma once

#include "CoreMinimal.h"
#include "Abilities/GameplayAbility.h"
#include "InteractionOption.h"
#include "IInteractableTarget.generated.h"

struct FInteractionQuery;

/**  */
class FInteractionOptionBuilder
{
public:
    FInteractionOptionBuilder(TScriptInterface<IInteractableTarget> InterfaceTargetScope, TArray<FInteractionOption>& InteractOptions)
       : Scope(InterfaceTargetScope)
       , Options(InteractOptions)
    {
    }

    void AddInteractionOption(const FInteractionOption& Option)
    {
       FInteractionOption& OptionEntry = Options.Add_GetRef(Option);
       OptionEntry.InteractableTarget = Scope;
    }

private:
    TScriptInterface<IInteractableTarget> Scope;
    TArray<FInteractionOption>& Options;
};

/**  */
UINTERFACE(MinimalAPI, meta = (CannotImplementInterfaceInBlueprint))
class UInteractableTarget : public UInterface
{
    GENERATED_BODY()
};

/**  */
class IInteractableTarget
{
    GENERATED_BODY()

public:
    /**  */
    virtual void GatherInteractionOptions(const FInteractionQuery& InteractQuery, FInteractionOptionBuilder& OptionBuilder) = 0;

    /**  */
    virtual void CustomizeInteractionEventData(const FGameplayTag& InteractionEventTag, FGameplayEventData& InOutEventData) { }
};
```

​	乍一看这个接口并不太好理解，我们需要从其他地方入手。可以关注到IInteractableTarget提供了两个待覆写的函数，其中 GatherInteractionOptions中提出的InteractionOptions看起来是一个有趣的概念，我们试图从其入手了解Lyra的Interaction，但是我们注意到这个函数的参数中并没有一个InteractionOption，但是FInteractionOptionBuilder看起来是一个相关的东西，而它就定义在本头文件中。

#### 1.1 InteractionOptionBuilder

​	可以注意到，它只是一个纯C++类，没有UCLASS反射宏，可以推断出只是一个**中介工具类**。它维护了两个私有字段：

- TScriptInterface<IInteractableTarget> Scope
- TArray<FInteractionOption>& Options

​	可见它担负着承载一系列FInteractionOption的作用，再看其函数AddInteractionOption，其将一个Option整合到了一个TArray<FInteractionOption>& Options上，这是一个数组引用，可见其是用来填写外部的一个TArray<FInteractionOption>的。并且把Option中的OptionEntry.InteractableTarget赋值了自己的Scope，可见实际上这个Scope也只是用来帮助Option填入自己的来源的，因为一个InteractableTarget上的Option没法自己填写自己的来源也就是InteractableTarget自己。可见这个函数应该起到了读取某东西上的FInteractionOption，并为其设置一个InteractableTarget的作用。

​	在后面我们会看到，InteractionOptionBuilder就是一个纯纯的工具人，只是用来填写Option数组的。

​	接下来来看InteractionOption。

#### 1.2 InteractionOption

InteractionOption.h

```c++
#pragma once

#include "CoreMinimal.h"
#include "Abilities/GameplayAbility.h"
#include "InteractionOption.generated.h"

class IInteractableTarget;
class UUserWidget;

/**  */
USTRUCT(BlueprintType)
struct FInteractionOption
{
    GENERATED_BODY()

public:
    /** The interactable target */
    UPROPERTY(BlueprintReadWrite)
    TScriptInterface<IInteractableTarget> InteractableTarget;

    /** Simple text the interaction might return */
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    FText Text;

    /** Simple sub-text the interaction might return */
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    FText SubText;

    // METHODS OF INTERACTION
    //--------------------------------------------------------------

    // 1) Place an ability on the avatar that they can activate when they perform interaction.

    /** The ability to grant the avatar when they get near interactable objects. */
    UPROPERTY(EditAnywhere, BlueprintReadOnly)
    TSubclassOf<UGameplayAbility> InteractionAbilityToGrant;

    // - OR -

    // 2) Allow the object we're interacting with to have its own ability system and interaction ability, that we can activate instead.

    /** The ability system on the target that can be used for the TargetInteractionHandle and sending the event, if needed. */
    UPROPERTY(BlueprintReadOnly)
    TObjectPtr<UAbilitySystemComponent> TargetAbilitySystem = nullptr;

    /** The ability spec to activate on the object for this option. */
    UPROPERTY(BlueprintReadOnly)
    FGameplayAbilitySpecHandle TargetInteractionAbilityHandle;

    // UI
    //--------------------------------------------------------------

    /** The widget to show for this kind of interaction. */
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    TSoftClassPtr<UUserWidget> InteractionWidgetClass;

    //--------------------------------------------------------------

public:
    FORCEINLINE bool operator==(const FInteractionOption& Other) const
    {
       return InteractableTarget == Other.InteractableTarget &&
          InteractionAbilityToGrant == Other.InteractionAbilityToGrant&&
          TargetAbilitySystem == Other.TargetAbilitySystem &&
          TargetInteractionAbilityHandle == Other.TargetInteractionAbilityHandle &&
          InteractionWidgetClass == Other.InteractionWidgetClass &&
          Text.IdenticalTo(Other.Text) &&
          SubText.IdenticalTo(Other.SubText);
    }

    FORCEINLINE bool operator!=(const FInteractionOption& Other) const
    {
       return !operator==(Other);
    }

    FORCEINLINE bool operator<(const FInteractionOption& Other) const
    {
       return InteractableTarget.GetInterface() < Other.InteractableTarget.GetInterface();
    }
};
```

​	InteractionOption是一个结构体，其中维护了比较多的字段，其中关注其带EditAnywhere的成员，它们属于这个Option自己，而其它的成员用于存储Option从外界获取的信息。

​	注意到其中最特别的一个字段：

![image-20250203215057771](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250203215057771.png)

​	它表明了Lyra的交互思路是通过授予交互的主动方一个GameplayAbility来进行交互，所以一个InteractionOption就通过GA决定了一个可交互物的交互的内容。

​	我们查找InteractionOption的用法，可以发现只有LyraWorldCollectable中有维护FInteractionOption类型的成员：

![image-20250203215750497](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250203215750497.png)

​	现在我们就了解了一个InteractableTarget的基础是什么了，就是需要继承IInteractableTarget接口的Actor首先要自己**带有InteractionOption**，然后通过某种方式将自己带有的InteractionOption中携带的用于交互的GameplayAbility**授予交互的主体**。而要做到这点，Lyra给出的做法是让实现了IInteractableTarget接口的Actor用自己实现的GatherInteractionOptions()函数，结合使用InteractionOptionBuilder去整合好一个Actor身上带有的InteractionOptions，然后统一授予给交互主体，这允许Lyra中的InteractableTarget可以携带**多种“交互”**，只不过Lyra中唯一实现的交互只有LyraWorldCollectable，而它身上只有一个InteractionOption。这也使得LyraWorldCollectable重写的GatherInteractionOptions()函数非常简单，就是把自己的Option填入传入的InteractionOptionBuilder。

#### 1.3 GameplayAbility_Interact

​	在关心每个可交互物各自携带的交互GameplayAbility各自实现了什么之前，我们首先应关心Lyra是如何把InteractableTarget身上的交互GameplayAbility授予给交互主体也就是Player的。

​	我们可以发现，InteractableTarget并没有提供一个交互窗口似的函数，也就是说，让Player获得其携带的交互GameplayAbility并不是InteractableTarget主动实现的，那是怎样的呢？

​	原来，Player会在ShooterExplore模式中初始化时被授予一个GameplayAbility_Interact（准确来说是GA_Interact，是其蓝图子类）在这个GA中，会进行一些主动检索InteractableTarget的逻辑，接下来让我们来看一看。

先上代码：

```c++
class UIndicatorDescriptor;
class UObject;
class UUserWidget;
struct FFrame;
struct FGameplayAbilityActorInfo;
struct FGameplayEventData;

/**
 * ULyraGameplayAbility_Interact
 *
 * Gameplay ability used for character interacting
 */
UCLASS(Abstract)
class ULyraGameplayAbility_Interact : public ULyraGameplayAbility
{
    GENERATED_BODY()

public:

    ULyraGameplayAbility_Interact(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

    virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;

    UFUNCTION(BlueprintCallable)
    void UpdateInteractions(const TArray<FInteractionOption>& InteractiveOptions);

    UFUNCTION(BlueprintCallable)
    void TriggerInteraction();

protected:
    UPROPERTY(BlueprintReadWrite)
    TArray<FInteractionOption> CurrentOptions;

    UPROPERTY()
    TArray<TObjectPtr<UIndicatorDescriptor>> Indicators;

protected:

    UPROPERTY(EditDefaultsOnly)
    float InteractionScanRate = 0.1f;

    UPROPERTY(EditDefaultsOnly)
    float InteractionScanRange = 500;

    UPROPERTY(EditDefaultsOnly)
    TSoftClassPtr<UUserWidget> DefaultInteractionWidgetClass;
};
```

```c++
#include "LyraGameplayAbility_Interact.h"

#include "AbilitySystemComponent.h"
#include "Interaction/IInteractableTarget.h"
#include "Interaction/InteractionStatics.h"
#include "Interaction/Tasks/AbilityTask_GrantNearbyInteraction.h"
#include "NativeGameplayTags.h"
#include "Player/LyraPlayerController.h"
#include "UI/IndicatorSystem/IndicatorDescriptor.h"
#include "UI/IndicatorSystem/LyraIndicatorManagerComponent.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(LyraGameplayAbility_Interact)

class UUserWidget;

UE_DEFINE_GAMEPLAY_TAG_STATIC(TAG_Ability_Interaction_Activate, "Ability.Interaction.Activate");
UE_DEFINE_GAMEPLAY_TAG(TAG_INTERACTION_DURATION_MESSAGE, "Ability.Interaction.Duration.Message");

ULyraGameplayAbility_Interact::ULyraGameplayAbility_Interact(const FObjectInitializer& ObjectInitializer)
    : Super(ObjectInitializer)
{
    ActivationPolicy = ELyraAbilityActivationPolicy::OnSpawn;
    InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
    NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
}

void ULyraGameplayAbility_Interact::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData)
{
    Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData);

    UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
    if (AbilitySystem && AbilitySystem->GetOwnerRole() == ROLE_Authority)
    {
       UAbilityTask_GrantNearbyInteraction* Task = UAbilityTask_GrantNearbyInteraction::GrantAbilitiesForNearbyInteractors(this, InteractionScanRange, InteractionScanRate);
       Task->ReadyForActivation();
    }
}

void ULyraGameplayAbility_Interact::UpdateInteractions(const TArray<FInteractionOption>& InteractiveOptions)
{
    if (ALyraPlayerController* PC = GetLyraPlayerControllerFromActorInfo())
    {
       if (ULyraIndicatorManagerComponent* IndicatorManager = ULyraIndicatorManagerComponent::GetComponent(PC))
       {
          for (UIndicatorDescriptor* Indicator : Indicators)
          {
             IndicatorManager->RemoveIndicator(Indicator);
          }
          Indicators.Reset();

          for (const FInteractionOption& InteractionOption : InteractiveOptions)
          {
             AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);

             TSoftClassPtr<UUserWidget> InteractionWidgetClass = 
                InteractionOption.InteractionWidgetClass.IsNull() ? DefaultInteractionWidgetClass : InteractionOption.InteractionWidgetClass;

             UIndicatorDescriptor* Indicator = NewObject<UIndicatorDescriptor>();
             Indicator->SetDataObject(InteractableTargetActor);
             Indicator->SetSceneComponent(InteractableTargetActor->GetRootComponent());
             Indicator->SetIndicatorClass(InteractionWidgetClass);
             IndicatorManager->AddIndicator(Indicator);

             Indicators.Add(Indicator);
          }
       }
       else
       {
          //TODO This should probably be a noisy warning.  Why are we updating interactions on a PC that can never do anything with them?
       }
    }

    CurrentOptions = InteractiveOptions;
}

void ULyraGameplayAbility_Interact::TriggerInteraction()
{
    if (CurrentOptions.Num() == 0)
    {
       return;
    }

    UAbilitySystemComponent* AbilitySystem = GetAbilitySystemComponentFromActorInfo();
    if (AbilitySystem)
    {
       const FInteractionOption& InteractionOption = CurrentOptions[0];

       AActor* Instigator = GetAvatarActorFromActorInfo();
       AActor* InteractableTargetActor = UInteractionStatics::GetActorFromInteractableTarget(InteractionOption.InteractableTarget);

       // Allow the target to customize the event data we're about to pass in, in case the ability needs custom data
       // that only the actor knows.
       FGameplayEventData Payload;
       Payload.EventTag = TAG_Ability_Interaction_Activate;
       Payload.Instigator = Instigator;
       Payload.Target = InteractableTargetActor;

       // If needed we allow the interactable target to manipulate the event data so that for example, a button on the wall
       // may want to specify a door actor to execute the ability on, so it might choose to override Target to be the
       // door actor.
       InteractionOption.InteractableTarget->CustomizeInteractionEventData(TAG_Ability_Interaction_Activate, Payload);

       // Grab the target actor off the payload we're going to use it as the 'avatar' for the interaction, and the
       // source InteractableTarget actor as the owner actor.
       AActor* TargetActor = const_cast<AActor*>(ToRawPtr(Payload.Target));

       // The actor info needed for the interaction.
       FGameplayAbilityActorInfo ActorInfo;
       ActorInfo.InitFromActor(InteractableTargetActor, TargetActor, InteractionOption.TargetAbilitySystem);

       // Trigger the ability using event tag.
       const bool bSuccess = InteractionOption.TargetAbilitySystem->TriggerAbilityFromGameplayEvent(
          InteractionOption.TargetInteractionAbilityHandle,
          &ActorInfo,
          TAG_Ability_Interaction_Activate,
          &Payload,
          *InteractionOption.TargetAbilitySystem
       );
    }
}
```

##### AbilityTask_GrantNearbyInteraction

​	首先我们啥也不看，就只关注这个GA的ActivateAbility的部分，这个GA基类的ActivateAbility中只是准备了一个AbilityTask_GrantNearbyInteraction，这个AbilityTask的命名有点迷惑性，看似是向外给出Ability，实际上是把外部的Ability传给正在激活GA_Interact的Player。

代码：

```c++
#include "Abilities/Tasks/AbilityTask.h"

#include "AbilityTask_GrantNearbyInteraction.generated.h"

class UGameplayAbility;
class UObject;
struct FFrame;
struct FGameplayAbilitySpecHandle;
struct FObjectKey;

UCLASS()
class UAbilityTask_GrantNearbyInteraction : public UAbilityTask
{
    GENERATED_UCLASS_BODY()

    virtual void Activate() override;

    /** Wait until an overlap occurs. This will need to be better fleshed out so we can specify game specific collision requirements */
    UFUNCTION(BlueprintCallable, Category="Ability|Tasks", meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
    static UAbilityTask_GrantNearbyInteraction* GrantAbilitiesForNearbyInteractors(UGameplayAbility* OwningAbility, float InteractionScanRange, float InteractionScanRate);

private:

    virtual void OnDestroy(bool AbilityEnded) override;

    void QueryInteractables();

    float InteractionScanRange = 100;
    float InteractionScanRate = 0.100;

    FTimerHandle QueryTimerHandle;

    TMap<FObjectKey, FGameplayAbilitySpecHandle> InteractionAbilityCache;
};
```

```c++
UAbilityTask_GrantNearbyInteraction::UAbilityTask_GrantNearbyInteraction(const FObjectInitializer& ObjectInitializer)
    : Super(ObjectInitializer)
{
}

UAbilityTask_GrantNearbyInteraction* UAbilityTask_GrantNearbyInteraction::GrantAbilitiesForNearbyInteractors(UGameplayAbility* OwningAbility, float InteractionScanRange, float InteractionScanRate)
{
    UAbilityTask_GrantNearbyInteraction* MyObj = NewAbilityTask<UAbilityTask_GrantNearbyInteraction>(OwningAbility);
    MyObj->InteractionScanRange = InteractionScanRange;
    MyObj->InteractionScanRate = InteractionScanRate;
    return MyObj;
}

void UAbilityTask_GrantNearbyInteraction::Activate()
{
    SetWaitingOnAvatar();

    UWorld* World = GetWorld();
    World->GetTimerManager().SetTimer(QueryTimerHandle, this, &ThisClass::QueryInteractables, InteractionScanRate, true);
}

void UAbilityTask_GrantNearbyInteraction::OnDestroy(bool AbilityEnded)
{
    if (UWorld* World = GetWorld())
    {
       World->GetTimerManager().ClearTimer(QueryTimerHandle);
    }

    Super::OnDestroy(AbilityEnded);
}

void UAbilityTask_GrantNearbyInteraction::QueryInteractables()
{
    UWorld* World = GetWorld();
    AActor* ActorOwner = GetAvatarActor();
    
    if (World && ActorOwner)
    {
       FCollisionQueryParams Params(SCENE_QUERY_STAT(UAbilityTask_GrantNearbyInteraction), false);

       TArray<FOverlapResult> OverlapResults;
       World->OverlapMultiByChannel(OUT OverlapResults, ActorOwner->GetActorLocation(), FQuat::Identity, Lyra_TraceChannel_Interaction, FCollisionShape::MakeSphere(InteractionScanRange), Params);

       if (OverlapResults.Num() > 0)
       {
          TArray<TScriptInterface<IInteractableTarget>> InteractableTargets;
          UInteractionStatics::AppendInteractableTargetsFromOverlapResults(OverlapResults, OUT InteractableTargets);
          
          FInteractionQuery InteractionQuery;
          InteractionQuery.RequestingAvatar = ActorOwner;
          InteractionQuery.RequestingController = Cast<AController>(ActorOwner->GetOwner());

          TArray<FInteractionOption> Options;
          for (TScriptInterface<IInteractableTarget>& InteractiveTarget : InteractableTargets)
          {
             FInteractionOptionBuilder InteractionBuilder(InteractiveTarget, Options);
             InteractiveTarget->GatherInteractionOptions(InteractionQuery, InteractionBuilder);
          }

          // Check if any of the options need to grant the ability to the user before they can be used.
          for (FInteractionOption& Option : Options)
          {
             if (Option.InteractionAbilityToGrant)
             {
                // Grant the ability to the GAS, otherwise it won't be able to do whatever the interaction is.
                FObjectKey ObjectKey(Option.InteractionAbilityToGrant);
                if (!InteractionAbilityCache.Find(ObjectKey))
                {
                   FGameplayAbilitySpec Spec(Option.InteractionAbilityToGrant, 1, INDEX_NONE, this);
                   FGameplayAbilitySpecHandle Handle = AbilitySystemComponent->GiveAbility(Spec);
                   InteractionAbilityCache.Add(ObjectKey, Handle);
                }
             }
          }
       }
    }
}
```

​	先看其Activate中进行的事情，其在Activate中非常简单地设置了一个Timer用于按照给定的InteractionScanRate为周期，激活自己的一个内部函数QueryInteractables()，在这个函数中，先通过OverlapMultiByChannel去收集以Player的坐标为中心，给定检测半径InteractionScanRange的球体中的所有的启用了Lyra_TraceChannel_Interaction的Overlap的**“对象”**（之所以说对象是因为在后文我们可以看到Lyra的“交互”既可以涉及Actor，还可以涉及Component），可以在B_InteractableRock中发现它的StaticMesh设置了这个碰撞通道的Overlap：

![image-20250203225153728](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250203225153728.png)

​	然后通过Interaction相关的静态函数UInteractionStatics::AppendInteractableTargetsFromOverlapResults()去**挑出**Overlap结果数组中的实现了IInteractableTarget的Actor或Component。是的，Lyra设计的交互情形**不仅仅局限于Actor**，它还设计了可以让Component实现IInteractableTarget接口从而参与交互。

静态函数实现：

```c++
void UInteractionStatics::AppendInteractableTargetsFromOverlapResults(const TArray<FOverlapResult>& OverlapResults, TArray<TScriptInterface<IInteractableTarget>>& OutInteractableTargets)
{
    for (const FOverlapResult& Overlap : OverlapResults)
    {
       TScriptInterface<IInteractableTarget> InteractableActor(Overlap.GetActor());
       if (InteractableActor)
       {
          OutInteractableTargets.AddUnique(InteractableActor);
       }

       TScriptInterface<IInteractableTarget> InteractableComponent(Overlap.GetComponent());
       if (InteractableComponent)
       {
          OutInteractableTargets.AddUnique(InteractableComponent);
       }
    }
}
```

​	然后，挑出IInteractableTarget之后，就会把所有IInteractableTarget中的InteractionOptions通过其各自实现的GatherInteractionOptions()装载入一个InteractionOptionBuilder中，以此就获取到了检测半径内的InteractionOptions，实际上GatherInteractionOptions()还有一个参数，只不过在Lyra实现出来的交互内容中不需要这个东西：

![image-20250203232033419](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250203232033419.png)

FInteractionQuery的定义：

```c++
#include "CoreMinimal.h"
#include "Abilities/GameplayAbility.h"
#include "InteractionQuery.generated.h"


/**  */
USTRUCT(BlueprintType)
struct FInteractionQuery
{
    GENERATED_BODY()

public:
    /** The requesting pawn. */
    UPROPERTY(BlueprintReadWrite)
    TWeakObjectPtr<AActor> RequestingAvatar;

    /** Allow us to specify a controller - does not need to match the owner of the requesting avatar. */
    UPROPERTY(BlueprintReadWrite)
    TWeakObjectPtr<AController> RequestingController;

    /** A generic UObject to shove in extra data required for the interaction */
    UPROPERTY(BlueprintReadWrite)
    TWeakObjectPtr<UObject> OptionalObjectData;
};
```

​	InteractionQuery应该是提供了一种是否允许交互的查询，例如在某些游戏中，只允许某个阵营或某些玩家去和自己的设施交互这样的机制，或者不允许NPC去获得Player才允许进行的某些交互这，这就没必要让它们拿到这个InteractionOption了（这些或许可以通过检测一些Tag之类的）。

​	最后一步，AbilityTask_GrantNearbyInteraction做的就是去检查自己得到的Options中是否有需要的添加给交互主体的GA，这个Task会缓存一个Map来记录已经授予给交互主体的GASpecHandle，通过检查是否已经存有该Handle来避免重复添加GA。

![image-20250203233003891](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250203233003891.png)

![image-20250203233027878](C:/Users/Max1122Chen/AppData/Roaming/Typora/typora-user-images/image-20250203233027878.png)

​	所以，这个AbilityTask其实就是在做一件事情：周期性地检索交互主体周围的IInteractableTarget，把它们带有的起到实现交互的GA授予给交互主体。但是实际上这个AbilityTask并没有被Lyra的GA_Interact用到，因为这个Task在LyraGameplayAbility_Interact基类的Activate中调用，而实际上在Lyra的GA_Interact的Activate中并没有调用父类的Activate，所以算是没有用到，GA_Interact转而使用了另一个AbilityTask——UAbilityTask_WaitForInteractableTargets_SingleLineTrace，这个AbilityTask继承自UAbilityTask_WaitForInteractableTargets。

​	WaitForInteractableTargets_SingleLineTrace就并非采用周期性地作球体检测的一个大包围的交互逻辑了，而是采用周期性地进行射线检测。
