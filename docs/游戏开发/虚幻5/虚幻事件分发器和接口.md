# 虚幻接口和委托

首先需要明确，事件分发器和接口应当配合使用，并非二选一。

事件分发器和接口都是为了降低游戏内要素之间的依赖关系。

### 接口

​	接口允许你定义一系列函数，这些函数会描述一个类应该做出一些什么行为，但不实现这些函数，每个使用这个接口的类会自己给出自己的实现。例如你想要实现一个“交互”功能，允许你与NPC对话，与物品互动等，这些功能对于玩家来说是同一种行为，即“交互”但这些行为的具体实现是不同的。接口类中可以定义一系列函数，保证该接口的功能齐全，如上例中接口可以定义一个Interact描述具体的交互行为，定义一个CanInteract描述是否可以交互。

​	定义好一个接口类后，想要把它应用起来，需要在具体object类设置中增加“实现的接口”,然后实现其中的函数。接下来我们都按照“交互”功能这个例子展开。

#### 接口通信

​	在Player蓝图中直接写下当接收到尝试交互的输入时的逻辑，我们采取如下策略：以player为中心进行球体检测，调用检测到的物体的interact接口，很神奇吧！这样就实现了两个类之间的通信，而且player并不在乎对方是什么，只要对方实现了Interact就能通信。

注意：球体检测一次只检测一个actor，所以可能优先检测到了其他actor，而想要检测的物体没有反应。

#### 接口的优势

​	一方面接口降低了通信的耦合度，使得通信的灵活性和拓展性大大提高，另一方面避免了Cast to的硬引用，减少了资源浪费。

#### 类型转换二三事

​	由上面的例子我们可以看出，很多时候我们可以用接口替代类型转换，但并非在所有情况下类型转换都是不好的。右键一个Actor蓝图类，e.g.BP_PlayerCharacter，选择sizemap，查看它在加载时的内存占用。我们只要在蓝图中写任意的一个Cast to，就会在加载这个蓝图时把它内部Cast的任何类都复制一份引用，因为引擎认为这个类依赖于cast to的类。

​	然而并非任何情况都不应该用cast to，只需要保证用cast to的蓝图依赖cast to的目标类就可以了，因为他们之间本身就具有依赖，不会额外增加内存消耗。



### 事件分发器与委托

​	事件分发器的作用是在对象之间广播事件，通知一个事件的发生。例如在Player受伤时更新血条的值。

​	事件分发器与接口不同的点在于，接口最起码需要有意向的一个指向的目标，尽管这个指向的目标可能并不能明确，而事件分发器就是字面意义上的广播，谁订阅（监听）了该广播，谁就去回应。详细的例子可见“虚幻设计模式”中观察者模式和组件模式