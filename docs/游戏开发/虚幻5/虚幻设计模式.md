# 虚幻设计模式

## 设计模式（Design Pattern）概述

​	设计模式简单来说是一个模板或一种对常见软件工程问题解决方案的描述。

## 观察者模式（Observer Pattern）

​	观察者模式关注游戏中的**对象之间的信息通信**，例如下面的例子：

​	在一个封闭房间中，你将面对若干敌人，你击败所有敌人后，离开房间的通道就能打开，同时你的屏幕上有一个统计面板，统计目前剩余敌人，你需要关注如何向统计面板传达“当前敌人数量”的信息和向房间通道传达“敌人已被清理完毕”的信息。这类问题就是“观察者模式”关注的问题。

​	考虑**向统计面板传达“当前敌人数量”**这个任务，错误的做法是：在敌人的“death”事件函数中获取widget的引用后更新widget上敌人的数量，这种做法耦合了敌人和widget，或说使它们之间建立了依赖关系。这种做法导致如果你日后想要改写widget或enemy，你需要同时改写两者。

### 观察者模式的思想

​	观察者模式aka“发布者/订阅者模式”，它基于发生事件时进行信号广播的模式，当一个事件发生后，它可能进行广播，而那些订阅了该事件或正在监听该事件的对象接受到广播后就会做出反应。

### 观察者模式在UE中的实现

​	在蓝图编程中，观察者模式可以通过事件分发器（Event dispatcher）实现，而在C++中，需要靠委托实现。

#### 蓝图实现观察者模式

对发布者：在“My Blueprint”栏下找到事件分发器，添加一个事件，一般命名为“OnXXX”，表明其“有条件地触发”的性质。

对订阅者：首先需要获取对应发布者的引用，然后调用“Bind OnXXX”（对应事件），把一个自定义事件绑定到特点发布者实例的“OnXXX”事件上。

实际上，这和在C++中定义委托是非常相似的，同样使用了“Bind OnXXX”函数。

#### 观察者模式的优势

降耦合，使多个类之间的交互更易于更新和维护。

## 中介者模式（Meditator Pattern）

​	考虑这样一个任务：假设玩家是可被敌人攻击的，但你需要限制同时攻击玩家的敌人的数量，当未达上限时，就允许更多敌人攻击玩家，而当玩家死亡后，所有原来的攻击者回到平常的状态。如果考虑使用“观察者模式”实现，那么敌人之间的通信将变得**错综复杂**！这时就可以考虑使用“中介者模式”。

​	中介者模式关注这样的问题：如何在产生引用和依赖关系的情况下协调各个游戏对象之间的通信。

### 中介者模式的思想

​	中介者避免对象与对象之间产生直接练习以避免产生硬引用和依赖关系，转而通过一个中介处理对象与对象之间的关系。

​	就像现实中的空管系统，如果每台飞行器都要对其他所有飞行器告知“我将要起飞了，我想要使用1号跑道”，这条请求与其他飞行器的活动不矛盾则已，一旦发生矛盾，每台飞行器就要和其他所有飞行器吵架了。而现实中的做法当然是通过空管协调各方需求。

### 中介者模式在UE中的实现

​	继续考虑开始给出的例子，在UE中新建一个Actor称“Combat Manager”用于协调团战逻辑，它需要对一些对象保持跟踪，它们包括：被攻击对象，攻击者（Array），等待攻击者（Array），它们都只需声明成Actor类。

#### 通信实现

​	攻击者在攻击前需要询问中介是否允许攻击，得到许可后进行攻击，否则继续等待。这需要攻击者将两个函数暴露给中介：Attack()，Wait()，函数实现仍由攻击者负责，这需要使用“接口”。类似地，中介也应该知晓被攻击者允许多少个敌人攻击它，所以也要给被攻击者定义一个接口，方便传递“最大攻击者数”。



## 对象池模式（Object Pool Pattern）

​	考虑你要大量生成某种对象或销毁它们，但事实上直接调用“SpawnActor”或“DestroyActor”并不是特别好的方法，这可能导致性能和内存问题，生成和销毁对象都是比较昂贵的CPU操作，且经常性地分配与释放内存还会导致内存碎片。这时就可以使用”对象池模式“。

### 对象池模式的思想

​	对象池模式不同于即时2生成销毁对象的做法，对象池模式选择在最开始事先生成好若干对象并将其标记为未使用，这就称为

**”对象池“**，当你需要使用对象池中的对象时，就从中取出对象，将其标记为使用中，使用完毕后再把对象放回对象池，将其重新标记为”未使用“的状态。

### 对象池模式在UE中的实现

思路一：

创建一个新的Actor类称PooledActor，作为所有可以被添加进对象池Actor的父类

这个类需要定义两个变量：

- bool IsUse 是否被使用（离开对象池）
- Float TimetoLive 生命周期

还有一个函数：

- SetInUse()，作用是改变Actor的使用状态，并且改变Actor的碰撞启用、可视性和Actor的Tick的激活状态

再创建一个ActorComponent,用于依附在一个Actor上管理对象池对象的创建、激活和失活

## 组件模式（Component Pattern）

​	考虑你要做一个游戏，游戏需要实现几个功能：

1. 玩家有生命值，攻击力，可以进行攻击从而伤害某些对象。
2. 一些NPC可能具有生命值，攻击力，攻击手段等，也可能不具备其中某项。
3. 可能有一些非Character对象也具有生命值和其他属性和行为。

​	

两种普通的实现思路：

1. 为每一种类单独写属性和行为，显然太愚蠢了，pass。
2. 设计一个包罗万象的基类，其他各种类派生自基类。

​	

​	第二种设计看似美好，但实际上问题也很大。玩家本人需要生命值，攻击力，攻击手段等，但部分NPC可能不需要攻击相关的属性和行为，一些非Character对象也可能不需要角色移动的逻辑等等。这样的派生方式可能会导致大量的无用定义。

### 组件模式的思想

​	组件模式正是一种解决方案，为每一种独立的系统单独设立一个组件，为有功能需求的类配置对应功能的组件，这样既保证了可复用性，又避免了冗余消耗，使系统更干净。

### 组件模式在UE中的实现

​	创建一个派生自Actor Component的新类，在其中定义组件的基本功能，例如生命值组件需要追踪一个表示生命值的浮点值，定义一个Take Damage事件在受到伤害时根据伤害量减少生命值，并创建事件分发器为每一个装载了生命值组件的对象提供接口，例如在生命值改变时广播，对应角色监听到广播时做出特点反应。

#### 组件的额外好处

​	你可以通过一个组件在其事件图表中把另一个组件添加到第一个组件所在的actor上，例如你可以在生命值组件初始化时为其owner创建一个widget用于现实health bar，这样便不必为每一种需要现实health bar的actor重复添加widget，调整其位置，等等等等重复的工作。

#### 更灵活地使用组件

​	也许在上面所说的生命值组件中，你希望为某一类actor重用同一套改变生命值和响应其变化的逻辑，但你不希望在其上显示health bar，那么是否需要重写一套组件呢？通过“配置”，你可以避免重写一套组件，只需为特定的actor设置合适的参数就可以了。
