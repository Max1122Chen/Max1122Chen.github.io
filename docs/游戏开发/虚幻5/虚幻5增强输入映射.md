# 虚幻5增强输入

​	虚幻5改变了过去的输入映射的做法，使用了一套新的增强输入。

​	**Enhanced Input** 系统有四个主要概念：**Input Actions**、**Input Mapping Contexts**、**Input Modifiers** 和 **Input Triggers**。

​	应用增强输入映射系统的一个逻辑是为player动态添加或删除输入映射上下文，例如在登上车辆时才为角色添加关于控制车辆的上下文，下车时则删掉。

​	增强输入的一个优势是可以允许玩家同时拥有多个IMC，并设置不同的优先级，根据优先级顺序处理有冲突的输入

### 增强输入映射的逻辑：

​	Pawn的运动依赖于一个controller实例。对于玩家来说，玩家操作的角色与“游戏模式(Game Mode)”有关，在不同的关卡可能使用不同的游戏模式，使玩家控制的角色、角色的行为都可能不同。

![v](C:\Users\Max1122Chen\AppData\Roaming\Typora\typora-user-images\image-20241022182535016.png)

​	注意上图中，我们自定义了一个游戏模式，称MyGameMode01，我们在其中定义了玩家将操纵的角色（默认Pawn）=BP_PlayerCharacter01，这意味着我们会在该模式下操控该Pawn；且我们定义了玩家控制类=MyPlayerController01，这意味着我们将采用这个Controller中定义的方式来操控”默认Pawn“

​	要实现玩家输入能控制一个角色，需要为其定义一个输入映射上下文，并为玩家操纵的角色“装载”这个输入映射上下文，让角色知道要做什么。在输入映射上下文中，我们可以引入一种虚幻资产：输入操作。接着可以在输入映射上下文中为特定的输入操作配置输入映射，让某种输入操作可以接受多种键盘、鼠标甚至触摸等的输入。

​	注意，在上文提到，我们需要为角色”装载“输入映射上下文。实际上，虚幻给我们提供了Controller这个类，意味着它希望我们用它来管理角色也好，AI也好的各种行为，定义好一种可通用的Controller，就可以给各种角色使用，不需要对每一个角色都定义同样的逻辑，但编写移动逻辑仍需在实际的角色类中进行，因为Controller并不是Pawn，不具有移动的基础。所以，尽管可以在角色蓝图中的EventBeginPlay()中为角色装载输入映射上下文，但仍应该在PlayerController中完成这项工作。实际我们应该在PlayerController中完成所有输入控制逻辑，这里是简化了。

​	在Contoller中添加输入映射上下文的写法

![image-20241025173552534](C:\Users\Max1122Chen\AppData\Roaming\Typora\typora-user-images\image-20241025173552534.png)

​	有趣的是，在任何地方加载一个输入映射上下文不意味着给某Actor绑定了一个输入映射上下文，而是相当于”启用“了这个上下文，启用后，该上下文中包含的输入操作可以在各种地方被响应。

### 来让角色动起来吧（第三人称自由相机模式）

​	在输入映射上下文中添加一个输入操作，并添加上下左右移动的映射。我们选择用X定义前进方向移动，Y定义横向方向移动（然而虚幻5的示例中X和Y却是相反的，令人忍俊不禁）。

![image-20241022204045964](C:\Users\Max1122Chen\AppData\Roaming\Typora\typora-user-images\image-20241022204045964.png)

​	上图中，我们在输入操作中定义W是向前（X正方向），则我们将按下”W“产生的输入值（由于是键盘，默认输入1.0，手柄输入时可以是一个范围），传给Scale Value，表示以1倍朝World DIrection接收的方向（上例中是Forward）移动。配置左右移动类似。完成后角色可以僵硬地上下左右移动，不能旋转。

![image-20241022210714827](C:\Users\Max1122Chen\AppData\Roaming\Typora\typora-user-images\image-20241022210714827.png)

上图是ThirdPlayerCharacter中的实现，我们以此为基础继续叙述。

​	要实现按”A“或”D“时角色能面朝左或右移动，需要在”角色移动组件“将“将旋转朝向运动”勾选上，相当于把运动的方向也给了Pawn的旋转，并在角色根节点下将“Pawn”栏目下“使用控制器旋转Yaw”取消选择，让Pawn自己控制自己的Yaw旋转，这样才能让Pawn的旋转真正朝向自己的运动。完成上述步骤后play会发现角色的移动仍不合逻辑，此时的脚本中，角色的移动实际上是朝向一个**固定**的方向，wasd只是让角色转向其对应的方向后向该方向前进。此例中可以发现，我们是把角色对应的Controller的旋转为偏移量增加到了世界的“正右”方向，该方向是一个绝对方向。而此时我们还并未做任何事改变Controller的旋转，所以这个偏移增加后始终是一个定值，则角色的“左右”移动实际是朝一个绝对的世界方向移动。

​	这里有一个很“奇怪”的虚幻的逻辑，即虚幻默认从Character派生的自定义蓝图类要用Controller控制旋转？？？然而角色的移动又可以自己控制。

​	接下来，我们需要在弹簧臂组件中将“摄像机设置”中把“使用Pawn控制旋转”勾选上，这使得摄像机组件不会保持与根组件的相对位置（如果保持与根组件的相对位置，则角色在摄像机中的位置始终是不变的），启用这一项使摄像机的旋转必须要经过Pawn的控制，这样一来，再添加上鼠标**控制Controller旋转**的输入操作就可以了。**（实际上这样做是有问题的，这样导致摄像机的位置和旋转完全不听弹簧臂的控制，导致弹簧臂的臂长、旋转等本应控制摄像机变换的属性变得无用，这并非一种正确的做法。正确的做法很简单，不要让摄像机继承父组件的旋转就行了）**

​	此处可能会有疑惑，为什么控制Controller的旋转可以控制摄像机？因为在Controller中有一项默认勾选：“自动管理激活摄像机目标”，这使得Controller能操控摄像机，或者说这个设置使摄像机的行为绑定到了Controller上。

​	此处非常需要注意，上述的配置的结果是使角色能够像大量第三人称自由移动相机的情形一样操作，而这种操作用鼠标/手柄的移动控制Controller的（也是摄像机的）正方向，角色的前进操作会朝向该方向。这和第一人称的操作逻辑是不同的，第一人称中，鼠标/手柄控制摄像机正方向的同时也控制角色的正方向。



## 增强输入映射系统的优势

> 在不同的模式(状态)下可以加载对应的Input Mapping Context，很方便地隔离不同模式(状态)下输入事件触发的游戏逻辑
> 可以对Input Mapping Context分层管理（在《Crop Out》中会有例子）
> 运行时系统只需要轮询当前加载的Input Mapping Context中的Action，一定成度上提升了效率
> 刚才说到更多更细分的状态引脚也节省了我们很多代码
> ————————————————
>
>                             版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
>
> 原文链接：https://blog.csdn.net/ttm2d/article/details/132405963





