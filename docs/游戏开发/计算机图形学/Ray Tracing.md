# Ray Tracing

## Shadow Mapping

![image-20250928221722769](assets/image-20250928221722769.png)

![image-20250928221850604](assets/image-20250928221850604.png)

使用Shadow Mapping无需知道场景的几何信息

经典Shadow Mapping只能处理点光源下的阴影



![image-20250928222137342](assets/image-20250928222137342.png)

从光源向场景中看，记录看到的“深度”

![image-20250928222318853](assets/image-20250928222318853.png)

用摄像机再去看场景，对看到的点做一个向光源的虚拟屏幕的投影，比较投影后那个点对于光源的深度和光源缓存着的深度，如果前者比较大，则可以说明那个点被光源挡住了

![image-20250928222541837](assets/image-20250928222541837.png)

![image-20250928222725653](assets/image-20250928222725653.png)

![image-20250928222743619](assets/image-20250928222743619.png)

![image-20250928222815027](assets/image-20250928222815027.png)

![image-20250928222904244](assets/image-20250928222904244.png)

由于浮点精度的问题，上面的Shadow Mapping会有这种毛毛躁躁的东西

并且Shadow Mapping的分辨率也有关，分辨率低采样率低就容易走样

Shadow Mapping本质上是一个**光栅化**上的步骤

![image-20250928223527979](assets/image-20250928223527979.png)

![image-20250928223615227](assets/image-20250928223615227.png)

如果忽略光源的大小，阴影就会很硬



### 阴影的软硬——本影与半影

![image-20250928224007962](assets/image-20250928224007962.png)

有大小的光源能够产生半影



## Ray Tracing

![image-20250929111022852](assets/image-20250929111022852.png)

Glossy reflection：光滑的反射，但没有那么光滑

尽管光栅化能一定程度上实现上面的效果，但是终究效果不够好

![image-20250929111442927](assets/image-20250929111442927.png)



![image-20250929111635081](assets/image-20250929111635081.png)



### 基础光线追踪算法

![image-20250929112011517](assets/image-20250929112011517.png)

![image-20250929112213764](assets/image-20250929112213764.png)

![image-20250929112301629](assets/image-20250929112301629.png)

![image-20250929112423447](assets/image-20250929112423447.png)

在光线追踪中，我们假设摄像机是一个点，光源也是点光源，光线的反射都是完美的反射

![image-20250929112723886](assets/image-20250929112723886.png)

![image-20250929112812897](assets/image-20250929112812897.png)

![image-20250929112917678](assets/image-20250929112917678.png)

上面的光线追踪思想非常简单，由于光路可逆的缘故，我们可以从摄像机发出“视线”到场景中，对第一个遇到的空间点做判定，判定的方式是从光源向这个点发出一根光线，看看光能不能直接到达它，如果可以，这个点就可以被照亮

但是这样只能处理光线反弹一次的情况



#### Whited-Style Ray Tracing

![image-20250929113313696](assets/image-20250929113313696.png)

![image-20250929113640880](assets/image-20250929113640880.png)

光线可以继续折射/反射

![image-20250929113739239](assets/image-20250929113739239.png)

光的每个着落点都可以和光源进行连线进行计算，最终加和到着色的结果

当然每次光折射/反射都是应该有能量损失的

![image-20250929113950073](assets/image-20250929113950073.png)

光线的区分↑



## 光线相关的计算问题

![image-20250929114417416](assets/image-20250929114417416.png)

![image-20250929114655714](assets/image-20250929114655714.png)

![image-20250929114849327](assets/image-20250929114849327.png)



### **光线和隐式表面求交点**

![image-20250929115001703](assets/image-20250929115001703.png)



### **光线和三角形求交点**

![image-20250929115256816](assets/image-20250929115256816.png)

![image-20250929115505926](assets/image-20250929115505926.png)

光线和三角形求交点的方法分成两步：

1. 先求光线和三角形所在的平面是否有交点
2. 如果有交点，再求它是不是在三角形内（简单，之前做过很多次了）

![image-20250929115818144](assets/image-20250929115818144.png)

平面方程↑

![image-20250929120153247](assets/image-20250929120153247.png)

**能不能一次算出光线和三角形有没有交点？**

![image-20250929120344446](assets/image-20250929120344446.png)

ez，三角形内的点必然满足重心坐标，把光线上的点代入重心坐标表达式，然后解三个未知量：

t，α，β

最上面的式子看上去只有一个式子，实际上每个向量都是三维的，所以对x，y，z都可以有一条式子，所以就有了三条式子，就可以解三个未知量



## 加快光线和三角形表面求交点的过程

**怎么加快光线和三角形表面求交点的计算？**

![image-20250929122928698](assets/image-20250929122928698.png)

简单求交点的方法太慢了

![image-20250929123039932](assets/image-20250929123039932.png)





![image-20250929123210342](assets/image-20250929123210342.png)

把物体放在包围盒中，如果一根光线连物体的包围盒都碰不到，就更不会碰到抱起来的物体



对长方体的新理解：三个两两相对的平面的集合

![image-20250929123508695](assets/image-20250929123508695.png)

如何判定光线是否和包围盒相交？

 ![image-20250929124034738](assets/image-20250929124034738.png)

对包围盒的每两个“对面”分别计算光线与它们相交的时间，最后取时间段的交集，得到光线实际上在包围盒内的时间

![image-20250929124550650](assets/image-20250929124550650.png)

但是在这种计算下，还得考虑t算出来是负数的问题

![image-20250929124927875](assets/image-20250929124927875.png)



选择包围盒我们选择“横平竖直”（轴对齐，Axis-Aligned）的盒子，这样使得光线和包围盒求交点的计算会更简单



#### 如何利用AABB加速光线求交？

![image-20250930105704127](assets/image-20250930105704127.png)

![image-20250930105749499](assets/image-20250930105749499.png)

给包围盒划分网格（立体网格），然后给和物体表面相交的盒子变成灰色标记起来

光线先查询是否和某些盒子相交，再看看这个盒子是不是被标记为“灰色”，即这个盒子里有没有物体，如果有物体才去判定交点

加速效果怎样？

![image-20250930110748220](assets/image-20250930110748220.png)

![image-20250930110829274](assets/image-20250930110829274.png)

![image-20250930110851140](assets/image-20250930110851140.png)

![image-20250930111010245](assets/image-20250930111010245.png)



#### Spatial Partition

![image-20250930111314535](assets/image-20250930111314535.png)

虽然八叉树很直观，但八叉树没那么好用

KD-Tree的道理是，每次只把一个各自划分成两份，但不是均等二分，而且水平的切分和竖直的切分是交替的

BSP-Tree也是一种二分方式，但是它不是横平竖直的划分



##### KD-Tree 的建立

![image-20250930112130279](assets/image-20250930112130279.png)

只需要在叶子节点上存储几何形状

![image-20250930112504199](assets/image-20250930112504199.png)

![image-20250930112555940](assets/image-20250930112555940.png)

![image-20250930112724595](assets/image-20250930112724595.png)



**如何判定三角形和哪些盒子相交？**

很困难，导致KD-Tree的构造很麻烦

并且当一个物体和多个叶子节点上的盒子相交时，会导致被存储多份



#### Bounding Volume Hierarchy

BVH并非划分空间，而是划分物体

![image-20250930113846295](assets/image-20250930113846295.png)

![image-20250930113811459](assets/image-20250930113811459.png)

![image-20250930114040491](assets/image-20250930114040491.png)

BVH的一个好处是，它让每个物体只会被一个包围盒引用

BVH中最关键的是如何把一个大包围盒中的物体比较恰当地划分成两个新的包围盒

![image-20250930114401267](assets/image-20250930114401267.png)

![image-20250930115058002](assets/image-20250930115058002.png)

![image-20250930115151991](assets/image-20250930115151991.png)

![image-20250930115227109](assets/image-20250930115227109.png)

![image-20250930115343301](assets/image-20250930115343301.png)



## Radiometry

Radiometry 辐射度量学

![image-20250930120110146](assets/image-20250930120110146.png)



![image-20250930131313218](assets/image-20250930131313218.png)



### 物理量定义

#### Flux

![image-20250930131556475](assets/image-20250930131556475.png)

flux：通量，能流

![image-20250930131916934](assets/image-20250930131916934.png)

![image-20250930132040159](assets/image-20250930132040159.png)

#### Radiant intensity

![image-20250930132130319](assets/image-20250930132130319.png)

![image-20250930132828751](assets/image-20250930132828751.png)

##### Solid Angle

![image-20250930133116758](assets/image-20250930133116758.png)

![image-20250930133133814](assets/image-20250930133133814.png)

![image-20250930133241197](assets/image-20250930133241197.png)

intensity 表示的就是光在方向上的强度

如果在各方向上是均匀的，就是flux/4pi

#### Irradiance

![image-20250930142215692](assets/image-20250930142215692.png)

Irradiance 辐照度

![image-20250930142949839](assets/image-20250930142949839.png)

#### Radiance

![image-20250930143028068](assets/image-20250930143028068.png)

![image-20250930143104140](assets/image-20250930143104140.png)

![image-20250930143358284](assets/image-20250930143358284.png)

![image-20250930143716996](assets/image-20250930143716996.png)



![image-20250930143938695](assets/image-20250930143938695.png)

Irradiance：相当于一个小区域收到的能量

radiance：相当于一个小区域从某个方向收到的角度



### BRDF

![image-20250930144209312](assets/image-20250930144209312.png)

#### 反射到底是什么？

![image-20250930144252171](assets/image-20250930144252171.png)

#### The Reflection Equation

反射可以理解为光打到一个物体上的一个表面，然后被这个表面吸收了之后，这个表面再将它的部分重新发射出去

![image-20250930144803038](assets/image-20250930144803038.png)

![image-20250930145054761](assets/image-20250930145054761.png)

![image-20250930145409586](assets/image-20250930145409586.png)

#### The Rendering Equation

![image-20250930145652341](assets/image-20250930145652341.png)

在渲染方程中，所有的“方向”都认为是**从受光点出发**的

对于一个会自发光的点，只需要再加上它自发光的光，就从Reflection Equation 得到了Rendering Equation



单点光源：没有积分，因为只有一个点

![image-20250930150109001](assets/image-20250930150109001.png)

多点光源：不是积分而是求和，因为多点光源只是离散的

![image-20250930150153660](assets/image-20250930150153660.png)

加了面光源：面光源可以视作为点光源的集合，对立体角积分BRDF

![image-20250930150232882](assets/image-20250930150232882.png)



对非直接光源，也就是其他物体的反射，只需把它认为是一个光源

![image-20250930150354060](assets/image-20250930150354060.png)







![image-20250930150455692](assets/image-20250930150455692.png)

简化书写，为什么可以这么写先别问 

![image-20250930150854192](assets/image-20250930150854192.png)



一个神奇的从积分运算变成矩阵运算

![image-20250930150923689](assets/image-20250930150923689.png)

![image-20250930151118098](assets/image-20250930151118098.png)



![image-20251009102812662](assets/image-20251009102812662.png)

光栅化比较容易做的就是光源自发光和直接光照





![image-20251009102956580](assets/image-20251009102956580.png)

![image-20251009103008489](assets/image-20251009103008489.png)

![image-20251009103030340](assets/image-20251009103030340.png)

![image-20251009103057243](assets/image-20251009103057243.png)

当到四次弹射时，才能看见透明的玻璃，因为我们是从摄像机发出”视线“来收集光照信息，而在玻璃中，光线起码要弹几次才能出来



## 简单的概率论基础

![image-20251009103545214](assets/image-20251009103545214.png)

![image-20251009103715501](assets/image-20251009103715501.png)

![image-20251009103830158](assets/image-20251009103830158.png)



连续变量的概率：

![image-20251009103927563](assets/image-20251009103927563.png)

这个曲线叫做概率密度函数👆

![image-20251009104242396](assets/image-20251009104242396.png)



### 蒙特卡洛积分

![image-20251009110428375](assets/image-20251009110428375.png)

![image-20251009110454423](assets/image-20251009110454423.png)

对不好解析地解出结果的函数定积分，就可以采取蒙特卡洛积分的方法

蒙特卡洛积分就是一种**采样**的思想

![image-20251009110913117](assets/image-20251009110913117.png)



采用常数概率密度函数：

![image-20251009111153935](assets/image-20251009111153935.png)

![image-20251009111710067](assets/image-20251009111710067.png)





## Path Tracing

![image-20251009111913191](assets/image-20251009111913191.png)

Whitted-Style的光追只假设光线都遵从镜面反射的传播，这样就导致漫反射光被忽略了

 

![image-20251009112226442](assets/image-20251009112226442.png)

![image-20251009123359189](assets/image-20251009123359189.png)

![image-20251009123539233](assets/image-20251009123539233.png)

![image-20251009123838257](assets/image-20251009123838257.png)

![image-20251009124003124](assets/image-20251009124003124.png)

![image-20251009124207763](assets/image-20251009124207763.png)

![image-20251009124411851](assets/image-20251009124411851.png)

> [!IMPORTANT]
>
> 蒙特卡洛积分要求对谁采样就对谁积分，很重要，这是一个伏笔！！！

![image-20251009125622494](assets/image-20251009125622494.png)

想算来自Q照向P的光，可以把P当作一个观察点，如法炮制

![image-20251009125740332](assets/image-20251009125740332.png)

但是事情还没有解决，有两个问题：

1. 由于每次递归都再发出N条光线，当N ！= 1，递归时的计算规模会无限增大
2. 递归的结束条件没有给定



#### 解决规模爆炸的问题

![image-20251009170308113](assets/image-20251009170308113.png)

当且仅当N = 1时，计算规模才不会无限增大

![image-20251009170926085](assets/image-20251009170926085.png)

用N = 1的蒙特卡洛积分，就是Path Tracing

![image-20251009171009903](assets/image-20251009171009903.png)



采样方法：

![image-20251009171133283](assets/image-20251009171133283.png)



#### 解决递归不停止的问题

![image-20251009171505787](assets/image-20251009171505787.png)

![image-20251009171559271](assets/image-20251009171559271.png)

![image-20251009171818312](assets/image-20251009171818312.png)



改进后的伪代码：

![image-20251009171917678](assets/image-20251009171917678.png)



#### 采样率问题

![image-20251009172203400](assets/image-20251009172203400.png)

![image-20251009172307812](assets/image-20251009172307812.png)

当我们在着色点均匀向外采样时，如果光源离着色点很远，着色点向外随机发出射线打到光源的概率会很低，这样就导致准确率会很低。

如果我们能直接对光源采样，就不会浪费任何采样光线

![image-20251009172828231](assets/image-20251009172828231.png)

现在我们在光源上采样，但是我们要对着色点上的光照积分，为了满足蒙特卡洛积分的条件（对谁采样对谁积分），必须把dA转化成dω



![image-20251009173218725](assets/image-20251009173218725.png)



再度改良：



![image-20251009173446247](assets/image-20251009174921265.png)

![image-20251009173713648](assets/image-20251009173713648.png)

实际上这样算是分别计算了直接光照和间接光照



还有问题：

如果光源被挡住了怎么采样？

![image-20251009173931497](assets/image-20251009173931497.png)

加一个判断就行

![image-20251009174328190](assets/image-20251009174328190.png)

![image-20251009175420479](assets/image-20251009175420479.png)



![image-20251009180212726](assets/image-20251009180212726.png)

![image-20251009180515116](assets/image-20251009180515116.png)