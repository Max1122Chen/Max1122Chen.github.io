# Rasterization

![image-20250921165002843](assets/image-20250921165002843.png)

![image-20250921165101044](assets/image-20250921165101044.png)

Aspect ratio：宽高比

中间两道红线（从相机连向上下宽的中点）所夹的角度：Vertical Field of View：垂直可视角度

![image-20250921165914817](assets/image-20250921165914817.png)

注意这里X轴指向屏幕向外，相机看向-Z方向，所以相机的right方向是X正方向

![image-20250921170204354](assets/image-20250921170204354.png)



## 屏幕空间

![image-20250921170452827](assets/image-20250921170452827.png)

Raster：光栅 ==  德语中的“屏幕”



### 从正则立方体到屏幕空间

每个像素是1*1的正方形

![image-20250921170940297](assets/image-20250921170940297.png)



![image-20250921171152567](assets/image-20250921171152567.png)

把正则立方体XY平面变换成屏幕空间：

先把[-1,1] 大小缩放成宽width，高height，很简单就是一个简单的缩放

接着把拉完的平面的中心从（0，0）移动到（width/2，height/2），一个简单的平移，很简单。



### 成像设备

#### 阴极射线管

![image-20250921172210053](assets/image-20250921172210053.png)

隔行扫描：

利用人眼视觉暂留的效应，每次绘制只画一半，比如第一次只画奇数行，下一次只画偶数行

容易造成画面撕裂

#### 现代显示

![image-20250921172522381](assets/image-20250921172522381.png)

显存中的一块区域保存要显示的画面



平板显示器：

![image-20250921172636036](assets/image-20250921172636036.png)



液晶显示器：

![image-20250921172713022](assets/image-20250921172713022.png)

发光二极管：

![image-20250921172923614](assets/image-20250921172923614.png)



电子书：

刷新率很低

![image-20250921173014081](assets/image-20250921173014081.png)



### 三角形的作用

![image-20250921182320437](assets/image-20250921182320437.png)

- 最基础的多边形
  - 可以用来分解其他多边形
- 三角形一定是平的
- 三角形的内外是确定的



**怎么确定哪些像素亮哪些像素不亮？**

![image-20250921182531316](assets/image-20250921182531316.png)

#### 光栅化的简单方法：采样

判断一个像素的中心点是不是在三角形内，是就让那个像素亮

![image-20250921182920171](assets/image-20250921182920171.png)

![image-20250921183058739](assets/image-20250921183058739.png)

怎么判断一个点是不是在三角形内？

很简单，用叉乘（见“线性代数.md”）

![image-20250921194344058](assets/image-20250921194344058.png)

点落在三角形的边界上时怎么办？自行规定



![image-20250921194515843](assets/image-20250921194515843.png)

**遍历屏幕空间优化：**

只考虑紧密包围着三角形的“包围盒”内的像素

![image-20250921200143435](assets/image-20250921200143435.png)

**真正的屏幕：**

![image-20250921200356795](assets/image-20250921200356795.png)

三星（右边）的屏幕这种叫Bayer pattern

打印机：

![image-20250921200613652](assets/image-20250921200613652.png)

现在我们使用的采样方法的问题：锯齿严重！！！

![image-20250921200859939](assets/image-20250921200859939.png)



## 抗锯齿和反走样

![image-20250922140640994](assets/image-20250922140640994.png)

锯齿的学名->”走样“

抗锯齿本质是一个采样的问题，采样本质是一个信号的问题，详细研究可能要前往**”信号与系统“**

![image-20250922143244276](assets/image-20250922143244276.png)

![image-20250922143346409](assets/image-20250922143346409.png)

采样会产生”瑕疵“



摩尔纹：

![image-20250922143523601](assets/image-20250922143523601.png)

把左边的奇数行和奇数列去掉，再合在一起变成一张小的照片，再放大成原来的大小，就会变成右边的效果



![image-20250922143709277](assets/image-20250922143709277.png)

![image-20250922143748324](assets/image-20250922143748324.png)

**采样走样的本质是信号变化得太快了，但采样的速度没有跟上它**



采样之前先做模糊

![image-20250922143908842](assets/image-20250922143908842.png)

![image-20250922143947285](assets/image-20250922143947285.png)

![image-20250922144133692](assets/image-20250922144133692.png)

”先采样，再滤波“是不行的

![image-20250922144238583](assets/image-20250922144238583.png)

![image-20250922144451258](assets/image-20250922144451258.png)

### 频域分析

![image-20250922144524948](assets/image-20250922144524948.png)

![image-20250922144644638](assets/image-20250922144644638.png)

![image-20250922144959752](assets/image-20250922144959752.png)

![image-20250922145210331](assets/image-20250922145210331.png)



**"采样走样的本质是信号变化得太快了，但采样的速度没有跟上它"**的解释![image-20250922145705763](assets/image-20250922145705763.png)

**用一种采样频率，采两个频率截然不同的函数，采出来相同的结果，就是”走样“**

![image-20250922145944929](assets/image-20250922145944929.png)



什么是”滤波“？——把某些特定的频率删掉

![image-20250922150113262](assets/image-20250922150113262.png)

我们认为左边图像不同的空间代表了不同的”时域“（尽管它没有真正表示时间）

我们把左边的时域变成了右边的频域

右侧图越靠中心表示频率越低，越往外频率越高，越亮表示这个频率上携带的信息越多

![image-20250922150241772](assets/image-20250922150241772.png)

水平和竖直的两条线是怎么产生的？

我们认为图像时”周期性“变换的，看似只有这张图，但是我们认为它是”平铺“的，上下左右都是这张图，而图片不同的边界重叠时就会导致剧烈的信号变化，从而产生了水平和竖直的亮线



高通滤波：

![image-20250922151333901](assets/image-20250922151333901.png)

我们注意到，应用高通滤波之后，逆傅里叶变换得到的图片基本上是原来图片内部事物的分界线

为什么高频信号是图像内的边界？

图像的边界之所以是边界，就是因为它两侧图像的内容有比较明显的变化，例如黑白分界线，剧烈的变化->高频



低通滤波：

![image-20250922151749936](assets/image-20250922151749936.png)

显然和高通滤波相反的是，边界信息被模糊了



不低也不高通滤波

![image-20250922152052124](assets/image-20250922152052124.png)

提高通过的频率，边界越来越明显

![image-20250922152122247](assets/image-20250922152122247.png)



#### **滤波 = 卷积 = 平均**

![image-20250922152302029](assets/image-20250922152302029.png)

什么是卷积？以下是图形学中的**简化定义**：

![image-20250922152433597](assets/image-20250922152433597.png)

滤波器作为一个”滑动窗口“，在信号上滑动，上下两个3维向量做一个点乘（加权平均），最后把结果写在中间那格

![image-20250922152612369](assets/image-20250922152612369.png)



卷积定理：

两个信号时域上的卷积=两个信号频域上的乘积

![image-20250922152703852](assets/image-20250922152703852.png)



通过卷积，每个像素变成周围8个像素的的平均，可想而知就会产生模糊的效果



![image-20250922152836195](assets/image-20250922152836195.png)



这个9*9的东东叫做”卷积核“，它实现了”低通滤波“

![image-20250922153232911](assets/image-20250922153232911.png)

![image-20250922153753303](assets/image-20250922153753303.png)

更大的盒子变换得的频谱图变得更小（更大的卷积核模糊效果更强）

![image-20250922153920170](assets/image-20250922153920170.png)

#### 采样 = 重复频率内容

![image-20250922154032255](assets/image-20250922154032255.png)

图a是要采样的函数，采样就是只在函数上采集一些离散的点

图b是一些”冲击函数“，它只在一些位置有值，其他地方没有

我们把被采样函数和冲击函数乘起来，就得到了采样的结果

上面是两个函数在**时域上的乘积**，由卷积定理，**时域上的乘积等于频域上的卷积**，因此，我们把被采样函数和冲击函数傅里叶变换后得到的频域函数卷积，就得到了采样函数在频域上的结果，我们会发现它就是**被采样函数在不同频率上的重复！**

冲击函数经傅里叶变换后还是一些冲击函数



![image-20250922154115478](assets/image-20250922154115478.png)

采样不够快时，搬移的频谱就会重叠，这时就发生了走样

![image-20250922155139491](assets/image-20250922155139491.png)

由此，我们得出了反走样的方式：

#### 如何反走样？

![image-20250922155451365](assets/image-20250922155451365.png)

1. 增加采样率——提高分辨率（图形学）
2. 低通滤波——削去高频信号

![image-20250922155615338](assets/image-20250922155615338.png)

![image-20250922155733183](assets/image-20250922155733183.png)

采样简单，模糊怎么做呢？

![image-20250922155829794](assets/image-20250922155829794.png)

![image-20250922155954525](assets/image-20250922155954525.png)

![image-20250922160048479](assets/image-20250922160048479.png)

每个像素对被三角形覆盖的面积在像素内做一个灰度的平均，例如加入三角形覆盖了某个像素的80%，那么像素的灰度就是80%

但是这个方法计算难度有点大，人们采取了近似的方式

![image-20250922160434479](assets/image-20250922160434479.png)

![image-20250922160507355](assets/image-20250922160507355.png)

我们把一个像素再细分，考虑单个像素内有几个“小像素”被覆盖了（Yes or No），而不考虑具体覆盖的面积，用“有几成小像素被覆盖”近似“有多少面积被覆盖”，从而决定每个像素的上面所说的“灰度”，这就完成了抗锯齿的第一步“模糊”

MSAA完成的是“模糊+采样”

但是MSAA的问题是，增多了小采样点，导致计算量要变大了

![image-20250922161428590](assets/image-20250922161428590.png)

FXAA的做法是，先把图弄出来，检测出边界，再把边界模糊

TAA的做法是找上一帧的信息，用一个像素内不同的部分感知它自己在不在三角形内，由于帧与帧之间共用感知信息，就相当于把MSAA在一帧中单个像素内所有小像素的感知分布在了时间中



## Visibility/Occlusion

画家算法，模拟画家画油画的顺序，先画背景的东西，再画前景的东西

![image-20250922214336696](assets/image-20250922214336696.png)

画家算法的问题：无法处理复杂的深度问题

![image-20250922214539640](assets/image-20250922214539640.png)

图形学中的解决：

![image-20250922214751110](assets/image-20250922214751110.png)

生成画面时，不仅会生成实际的画面，还会生成一张“深度图”，记录离每个像素点最近的“深度”

![image-20250922215023122](assets/image-20250922215023122.png)

上面右图是一个深度图，深度越大，颜色越浅

![image-20250922215300056](assets/image-20250922215300056.png)

Z-Buffer算法本质上就是一个获得最小Z深度的擂台法，遍历所有三角形，遇到更浅的深度就更新深度图和生成图

![image-20250922215551809](assets/image-20250922215551809.png)

![image-20250922220257906](assets/image-20250922220257906.png)