# Shading & Texture

![image-20250923142842163](assets/image-20250923142842163.png)

![image-20250923143356273](assets/image-20250923143356273.png)

![image-20250923143512093](assets/image-20250923143512093.png)

## Blinn-Phong反射模型

![image-20250923143755242](assets/image-20250923143755242.png)

![image-20250923143908914](assets/image-20250923143908914.png)

- 高光
- 漫反射
- 间接光照

![image-20250923145039764](assets/image-20250923145039764.png)

暂时不考虑物体相互遮挡产生阴影的问题（后来写的：遮挡产生阴影起码要用shadow mapping）

![image-20250923145441172](assets/image-20250923145441172.png)

### 漫反射

![image-20250923145607511](assets/image-20250923145607511.png)

![image-20250923145652014](assets/image-20250923145652014.png)

![image-20250923152156504](assets/image-20250923152156504.png)

一个球壳上的能量是守恒的，当球壳扩大，即光线向外传播时，球壳上的能量密度会越来越低

![image-20250923152632694](assets/image-20250923152632694.png)

一个点接收到多少光，不仅取决于入射角，还和点离点光源的距离有关

一个点反射出多少光，取决于它接收到的光以及它对光的吸收

漫反射会向所有方向反射出相等强度的光

![image-20250923153353943](assets/image-20250923153353943.png)

### 高光

![image-20250923165444542](assets/image-20250923165444542.png)

高光的产生一般发生在比较光滑的物体上，越光滑越容易看到高光

原理是光滑的物体反射的光线几乎和完全的镜面反射的光线的出射角是非常相近的



![image-20250923165750364](assets/image-20250923165750364.png)

Blinn-Phong模型中

不是考虑的入射角和出射角是否足够接近，而是考虑光照方向和观察方向的”半程向量”与法向量之间的夹角

后面的max(0,cos a)上的指数p是为了降低cosine对偏离角的容忍度，毕竟cosine从0~1之间的变化比较“缓慢”，因此用指数p来提高其变化的速度，降低容忍度

Bling-Phong模型中会使用100~200的大小

![image-20250923170700000](assets/image-20250923170700000.png)

![image-20250923170858896](assets/image-20250923170858896.png)

### 环境光

![image-20250923170939988](assets/image-20250923170939988.png)

由于环境光太复杂了，我们假设整个环境光的强度是一个常数



Blinn-Phong模型合起来的反射效果：

![image-20250923171215499](assets/image-20250923171215499.png)



## 着色频率

![image-20250923171710187](assets/image-20250923171710187.png)

一个面着色一次 -> 

一个顶点着色一次（只考虑模型上的“顶点”，其他地方用插值 ->

每个像素着色一次





![image-20250923172029494](assets/image-20250923172029494.png)



![image-20250923172210308](assets/image-20250923172210308.png)



![image-20250923172308062](assets/image-20250923172308062.png)



![image-20250923172445667](assets/image-20250923172445667.png)



如何求顶点的法线？

![image-20250923172759102](assets/image-20250923172759102.png)

事实上，顶点的法线计算还需要合适的加权，例如考虑面积



![image-20250923173017245](assets/image-20250923173017245.png)



## 实时渲染管线

![image-20250923173235247](assets/image-20250923173235247.png)



![image-20250923173408711](assets/image-20250923173408711.png)

上面的做法是，先定义所有顶点，再定义哪些点会组成三角形



由于不同的着色频率，着色的应用可能会出现在不同的步骤中

shader就是控制顶点和像素如何着色的东东



![image-20250923173951983](assets/image-20250923173951983.png)



![image-20250923174038336](assets/image-20250923174038336.png)

shader是通用的，对每一个着色单位应用，不需要写循环在里面

![image-20250923190052062](assets/image-20250923190052062.png)

![image-20250923190231750](assets/image-20250923190231750.png)



## Texture Mapping

![image-20250923191158308](assets/image-20250923191158308.png)

![image-20250923191341039](assets/image-20250923191341039.png)

texture 纹理 -> 一张图片

![image-20250923191540224](assets/image-20250923191540224.png)



红颜色表示u坐标比较大，绿颜色表示v坐标比较大

一般来说认为u，v在0~1内

![image-20250923191820807](assets/image-20250923191820807.png)

![image-20250924203523208](assets/image-20250924203523208.png)

![image-20250924203629683](assets/image-20250924203629683.png)

tilable texture -> 可以重复的纹理



![image-20250924203729960](assets/image-20250924203729960.png)

![image-20250924204354839](assets/image-20250924204354839.png)

### 三角形内部插值

![image-20250924204716860](assets/image-20250924204716860.png)

#### 重心坐标

![image-20250924204735201](assets/image-20250924204735201.png)

三角形内的点可以用三角形的三个顶点的坐标的线性组合来表示

其中α + β + γ = 1，且它们非负

α ，β， γ可以认为是三个顶点对三角形内部点的”贡献“，也就可以成为其他属性的权重

γ = 1 - α - β，所以实际上只有两个变量

![image-20250924205410530](assets/image-20250924205410530.png)

这里的大A指的是Area，即面积

![image-20250924210855235](assets/image-20250924210855235.png)

![image-20250924210935241](assets/image-20250924210935241.png)

![image-20250924211127726](assets/image-20250924211127726.png)

重心坐标虽然不难算，但是投影前后并不能保证坐标不变

所以重心坐标应当在投影前计算三维的投影坐标



### 应用纹理

![image-20250924212210631](assets/image-20250924212210631.png)

（u，v）是（x，y）的重心坐标，因此总是在0~1内，得到重心坐标后，就去纹理中查对应的坐标

#### 纹理过小问题



![image-20250924212539122](assets/image-20250924212539122.png)

![image-20250924212745594](assets/image-20250924212745594.png)

邻近 -> 双线性 -> 不会翻译

##### 双线性插值

![image-20250924212947505](assets/image-20250924212947505.png)

![image-20250924213112679](assets/image-20250924213112679.png)

![image-20250924213313774](assets/image-20250924213313774.png)

![image-20250924213427571](assets/image-20250924213427571.png)

双线性插值 ！= 插值两次



#### 纹理过大问题

![image-20250924213914420](assets/image-20250924213914420.png)

![image-20250924214137363](assets/image-20250924214137363.png)

![image-20250924214235015](assets/image-20250924214235015.png)

表现画面近处的像素所涉及的纹理区域的大小是相对较小的，但表现画面远处的像素所涉及的纹理区域大小变得很大

![image-20250924214907723](assets/image-20250924214907723.png)

采样率不足会导致走样

那如果我们减少采样呢？

![image-20250924215200795](assets/image-20250924215200795.png)



##### Mipmap

![image-20250924215258506](assets/image-20250924215258506.png)

![image-20250924215353682](assets/image-20250924215353682.png)

Mipmap只能做方形的范围查询

![image-20250924215612989](assets/image-20250924215612989.png)

产生Mipmap会导致的额外存储量为原来存储量的1/3 （等比级数求和）



如何确定对某个像素它所覆盖的三角形的纹理应该是Mipmap的第几个层级？

从（x，y）坐标转换到（u，v）坐标以后，原来在屏幕空间上相邻的两个像素之间的距离会由于（u，v）映射而发生一定的相对变化

![image-20250924220548215](assets/image-20250924220548215.png)

![image-20250924220657584](assets/image-20250924220657584.png)

![image-20250924220729151](assets/image-20250924220729151.png)

计算出变换到（u，v）坐标后相邻像素之间的间距，就可以近似为原来像素变换后在（u，v）坐标下的边长，以此可以近似变换后像素覆盖的面积

假如这个区域的大小是4*4，它在D = log2L =  2层上会变成一个像素，所以要在D = 2层查询它的范围

![image-20250925160537216](assets/image-20250925160537216.png)

现在我们只能离散地查询第i层 ， i是整数，这就会导致在物理上邻近的地方查询出来的层次可能不同，导致出现一些割裂感，我们能否获得任意正实数层上查询的结果？

![image-20250925160626227](assets/image-20250925160626227.png)

![image-20250925160827758](assets/image-20250925160827758.png)

通过层内的插值加上层与层之间的插值，可以查任意正实数层对应的值，这是一个三线性插值

![image-20250925205152183](assets/image-20250925205152183.png)

##### Mipmap的局限性

会导致过度模糊

![image-20250925205310959](assets/image-20250925205310959.png)

**各向异性过滤：**

![image-20250925205414426](assets/image-20250925205414426.png)



![image-20250925205529129](assets/image-20250925205529129.png)

mipmap实际上产生了对角线上的一系列图，但没有产生那些不均匀的压缩图片

mipmap只能查询方形的区域，但这些不均匀压缩的纹理可以查询矩形的区域

各项异性过滤所产生的额外开销为原来的三倍

![image-20250925205941949](assets/image-20250925205941949.png)

但各项异性查询也只能解决部分问题

![image-20250925210121865](assets/image-20250925210121865.png)

EWA查询采用多次查询



![image-20250925211414098](assets/image-20250925211414098.png)

![image-20250925211603087](assets/image-20250925211603087.png)



![image-20250925211709322](assets/image-20250925211709322.png)

对待环境光时，假设环境光都是从无限远传来，只研究方向的问题

![image-20250925212048503](assets/image-20250925212048503.png)

![image-20250925212132915](assets/image-20250925212132915.png)

把环境光存储在一个球上，存在的问题：扭曲

![image-20250925212246473](assets/image-20250925212246473.png)

![image-20250925212411763](assets/image-20250925212411763.png)

改为把环境光照信息存在球的包围盒上

![image-20250925212636764](assets/image-20250925212636764.png)



![image-20250925212759038](assets/image-20250925212759038.png)

可以定义一个点沿着法线的相对高度，来产生复杂的纹理

![image-20250925213301978](assets/image-20250925213301978.png)

凹凸贴图可以改变面上的法线

![image-20250925213551801](assets/image-20250925213551801.png)

二维上可以通过切线求法线



![image-20250925214245376](assets/image-20250925214245376.png)



**位移贴图**

![image-20250926104911588](assets/image-20250926104911588.png)

位移贴图会真的改变模型的顶点位置

但局限性是需要模型的顶点密度要跟得上纹理上的变化，依旧是一个采样率的问题



**3D纹理**

![image-20250926105326730](assets/image-20250926105326730.png)



**预计算阴影**

![image-20250926105456995](assets/image-20250926105456995.png)





![image-20250926105636771](assets/image-20250926105636771.png)